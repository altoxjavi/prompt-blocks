<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>üçå Prompt Blocks - v2.56 - Blueprint State & Actions</title>
  <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Syne:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    /* Prevent text selection on interactive areas */
    .library-panel,
    .builder-panel,
    .slots-container,
    .category-phrases {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    
    /* Allow text selection only in preview */
    .preview-content {
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      user-select: text;
    }
    
    body {
      font-family: 'Space Mono', monospace;
      background: #0a0a0f;
      min-height: 100vh;
      color: #e0e0e0;
      display: flex;
      flex-direction: column;
    }
    
    /* Header */
    .app-header {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      padding: 16px 24px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
    }
    
    .app-title {
      font-family: 'Syne', sans-serif;
      font-size: 24px;
      font-weight: 800;
      background: linear-gradient(135deg, #FF6B6B, #4ECDC4, #45B7D1);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      letter-spacing: -1px;
    }
    
    .app-subtitle {
      font-size: 10px;
      color: #888;
      margin-top: 2px;
      letter-spacing: 2px;
      text-transform: uppercase;
    }
    
    .header-actions {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    
    .header-actions button {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      color: #aaa;
      padding: 8px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-family: 'Space Mono', monospace;
      font-size: 12px;
      transition: all 0.2s;
    }
    
    .header-actions button:hover {
      background: rgba(255,255,255,0.1);
      color: #fff;
      border-color: rgba(255,255,255,0.2);
    }
    
    .settings-btn {
      background: rgba(78, 205, 196, 0.1) !important;
      border: 1px solid rgba(78, 205, 196, 0.3) !important;
      color: #4ECDC4 !important;
    }
    
    .settings-btn:hover {
      background: rgba(78, 205, 196, 0.2) !important;
      border-color: rgba(78, 205, 196, 0.5) !important;
    }
    
    /* Edit mode button */
    .edit-btn {
      background: rgba(255, 107, 107, 0.1) !important;
      border: 1px solid rgba(255, 107, 107, 0.3) !important;
      color: #FF6B6B !important;
    }
    
    .edit-btn.active {
      background: rgba(255, 107, 107, 0.3) !important;
      border-color: #FF6B6B !important;
      color: #fff !important;
    }
    
    /* Main layout */
    .app-main {
      display: grid;
      grid-template-columns: 320px 1fr 380px;
      flex: 1;
      overflow: hidden;
      height: calc(100vh - 70px);
    }
    
    /* Library Panel */
    .library-panel {
      background: #0f0f18;
      border-right: 1px solid rgba(255,255,255,0.05);
      overflow-y: auto;
      display: flex;
      flex-direction: column;
    }
    
    .library-header {
      padding: 16px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      flex-shrink: 0;
    }
    
    .library-header h2 {
      font-family: 'Syne', sans-serif;
      font-size: 16px;
      font-weight: 600;
    }
    
    .library-subtitle {
      font-size: 10px;
      color: #666;
      margin-top: 4px;
    }
    
    .library-blueprint-actions {
      display: flex;
      gap: 6px;
      margin: 12px 0 8px 0;
    }
    
    .library-action-btn {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      padding: 8px 6px;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      color: #888;
      font-size: 10px;
      font-family: 'Space Mono', monospace;
      cursor: pointer;
      transition: all 0.15s;
      -webkit-tap-highlight-color: transparent;
    }
    
    .library-action-btn:hover {
      background: rgba(78, 205, 196, 0.1);
      border-color: rgba(78, 205, 196, 0.3);
      color: #4ECDC4;
    }
    
    .library-action-btn:active {
      transform: scale(0.98);
    }
    
    .library-action-btn span {
      font-size: 12px;
    }
    
    .library-categories {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
      -webkit-overflow-scrolling: touch;
    }
    
    /* Add folder button */
    .add-folder-btn {
      width: 100%;
      padding: 12px;
      margin-bottom: 8px;
      background: rgba(78, 205, 196, 0.05);
      border: 1px dashed rgba(78, 205, 196, 0.3);
      border-radius: 8px;
      color: #4ECDC4;
      font-family: 'Space Mono', monospace;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .add-folder-btn:hover {
      background: rgba(78, 205, 196, 0.1);
      border-color: #4ECDC4;
    }
    
    .library-category {
      margin-bottom: 6px;
      position: relative;
    }
    
    .category-header {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 14px;
      border: 1px solid rgba(255,255,255,0.1);
      border-left: 3px solid var(--cat-color);
      border-radius: 8px;
      color: #fff;
      cursor: pointer;
      font-family: 'Space Mono', monospace;
      font-size: 11px;
      transition: all 0.2s;
      position: relative;
    }
    
    .category-header:hover {
      filter: brightness(1.1);
    }
    
    .category-header.expanded {
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
    }
    
    .category-header-left {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
    }
    
    .category-header-right {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
    }
    
    .category-count {
      background: rgba(255,255,255,0.1);
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 10px;
    }
    
    .category-arrow {
      font-size: 10px;
      color: #666;
      transition: transform 0.2s;
    }
    
    .category-header.expanded .category-arrow {
      transform: rotate(90deg);
    }
    
    /* Edit mode - folder controls - REMOVED, using drag instead */
    .folder-controls {
      display: none !important;
    }
    
    /* Trash bin for edit mode */
    .trash-bin {
      display: none;
      position: sticky;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 20px;
      background: linear-gradient(to top, rgba(15, 15, 24, 1) 0%, rgba(15, 15, 24, 0.95) 70%, rgba(15, 15, 24, 0) 100%);
      text-align: center;
      z-index: 100;
    }
    
    .library-panel.edit-mode .trash-bin {
      display: block;
    }
    
    .trash-bin-target {
      padding: 16px 24px;
      border: 2px dashed rgba(255, 107, 107, 0.3);
      border-radius: 12px;
      color: #FF6B6B;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.2s;
      background: rgba(255, 107, 107, 0.05);
    }
    
    .trash-bin-target.drag-over {
      border-color: #FF6B6B;
      background: rgba(255, 107, 107, 0.2);
      transform: scale(1.02);
      box-shadow: 0 0 30px rgba(255, 107, 107, 0.3);
    }
    
    .trash-bin-target .trash-icon {
      font-size: 24px;
      display: block;
      margin-bottom: 4px;
    }
    
    /* Draggable folder header in edit mode */
    .library-panel.edit-mode .category-header {
      cursor: grab;
    }
    
    .library-panel.edit-mode .category-header:active {
      cursor: grabbing;
    }
    
    .category-header.dragging-folder {
      opacity: 0.5;
      transform: scale(0.98);
    }
    
    .library-category.drag-over-folder {
      border-top: 2px solid #4ECDC4;
    }
    
    .library-category.drag-over-folder-below {
      border-bottom: 2px solid #4ECDC4;
    }
    
    /* Color picker button (edit mode only) */
    .folder-color-btn {
      display: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 2px solid rgba(255,255,255,0.3);
      cursor: pointer;
      transition: all 0.15s;
      flex-shrink: 0;
      margin-left: 4px;
    }
    
    .folder-color-btn:hover {
      transform: scale(1.1);
      border-color: rgba(255,255,255,0.6);
    }
    
    .library-panel.edit-mode .folder-color-btn {
      display: block;
    }
    
    /* Folder action buttons (edit mode) */
    .folder-action-btn {
      display: none;
      width: 24px;
      height: 24px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      transition: all 0.15s;
      flex-shrink: 0;
      margin-left: 4px;
      font-size: 12px;
      background: rgba(255,255,255,0.1);
      color: #aaa;
      -webkit-tap-highlight-color: transparent;
    }
    
    .folder-action-btn:hover {
      background: rgba(255,255,255,0.2);
      color: #fff;
    }
    
    .folder-action-btn:active {
      transform: scale(0.95);
    }
    
    .folder-action-btn.duplicate {
      background: rgba(78, 205, 196, 0.15);
      color: #4ECDC4;
    }
    
    .folder-action-btn.duplicate:hover {
      background: rgba(78, 205, 196, 0.3);
    }
    
    .folder-action-btn.delete {
      background: rgba(255, 107, 107, 0.15);
      color: #FF6B6B;
    }
    
    .folder-action-btn.delete:hover {
      background: rgba(255, 107, 107, 0.3);
    }
    
    .library-panel.edit-mode .folder-action-btn {
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    /* Tappable folder label in edit mode */
    .folder-label {
      transition: all 0.15s;
    }
    
    .library-panel.edit-mode .folder-label {
      cursor: pointer;
      padding: 2px 6px;
      margin: -2px -6px;
      border-radius: 4px;
    }
    
    .library-panel.edit-mode .folder-label:hover {
      background: rgba(255,255,255,0.1);
    }
    
    .library-panel.edit-mode .folder-label:active {
      background: rgba(255,255,255,0.15);
    }
    
    /* Color picker popover - now a fixed overlay */
    .color-picker-popover {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #1a1a2e;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 16px;
      padding: 16px;
      z-index: 2000;
      box-shadow: 0 20px 60px rgba(0,0,0,0.7);
      display: none;
      -webkit-tap-highlight-color: transparent;
      width: 280px;
    }
    
    .color-picker-popover.active {
      display: block;
    }
    
    .color-picker-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 1999;
      display: none;
    }
    
    .color-picker-overlay.active {
      display: block;
    }
    
    .color-picker-title {
      font-size: 11px;
      color: #888;
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
      text-align: center;
    }
    
    .color-picker-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 8px;
      justify-items: center;
    }
    
    .color-option {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.15s;
      -webkit-tap-highlight-color: transparent;
    }
    
    .color-option:hover {
      transform: scale(1.1);
      border-color: rgba(255,255,255,0.5);
    }
    
    .color-option:active {
      transform: scale(0.95);
    }
    
    .color-option.selected {
      border-color: #fff;
      box-shadow: 0 0 0 2px rgba(255,255,255,0.3);
    }
    
    /* Blueprint modal */
    .blueprint-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      z-index: 2999;
      display: none;
    }
    
    .blueprint-overlay.active {
      display: block;
    }
    
    .blueprint-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #1a1a2e;
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 20px;
      padding: 24px;
      z-index: 3000;
      box-shadow: 0 30px 80px rgba(0,0,0,0.8);
      display: none;
      max-width: 90vw;
      max-height: 85vh;
      width: 600px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }
    
    .blueprint-modal.active {
      display: block;
    }
    
    .blueprint-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    
    .blueprint-modal-header h3 {
      font-family: 'Syne', sans-serif;
      font-size: 18px;
      color: #fff;
      margin: 0;
    }
    
    .blueprint-modal-header-actions {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .blueprint-edit-btn {
      background: rgba(255, 165, 77, 0.15);
      border: 1px solid rgba(255, 165, 77, 0.3);
      color: #FFA94D;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.15s;
    }
    
    .blueprint-edit-btn:hover {
      background: rgba(255, 165, 77, 0.25);
    }
    
    .blueprint-edit-btn.active {
      background: rgba(78, 205, 196, 0.2);
      border-color: rgba(78, 205, 196, 0.4);
      color: #4ECDC4;
    }
    
    .blueprint-close-btn {
      background: rgba(255,255,255,0.1);
      border: none;
      color: #888;
      width: 32px;
      height: 32px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 18px;
      transition: all 0.15s;
    }
    
    .blueprint-close-btn:hover {
      background: rgba(255,255,255,0.2);
      color: #fff;
    }
    
    .blueprint-modal-description {
      font-size: 12px;
      color: #666;
      margin-bottom: 20px;
    }
    
    .blueprint-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 12px;
      max-height: 55vh;
      overflow-y: auto;
      padding: 4px;
      margin: 0 -4px;
    }
    
    .blueprint-card {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      padding: 16px;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
      -webkit-tap-highlight-color: transparent;
    }
    
    .blueprint-card:hover {
      background: rgba(255,255,255,0.06);
      border-color: rgba(78, 205, 196, 0.3);
      transform: translateY(-2px);
    }
    
    .blueprint-card:active {
      transform: translateY(0);
    }
    
    .blueprint-card.active {
      border-color: #4ECDC4;
      background: rgba(78, 205, 196, 0.1);
    }
    
    .blueprint-card-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }
    
    .blueprint-icon {
      font-size: 20px;
    }
    
    .blueprint-name {
      font-family: 'Syne', sans-serif;
      font-size: 14px;
      font-weight: 600;
      color: #fff;
      flex: 1;
    }
    
    .blueprint-delete-btn {
      background: rgba(255, 107, 107, 0.15);
      border: 1px solid rgba(255, 107, 107, 0.3);
      color: #FF6B6B;
      padding: 6px 10px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 11px;
      line-height: 1;
      transition: all 0.15s;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    
    .blueprint-delete-btn:hover,
    .blueprint-delete-btn:active {
      background: rgba(255, 107, 107, 0.3);
    }
    
    .blueprint-meta {
      font-size: 10px;
      color: #555;
      font-family: 'Space Mono', monospace;
    }
    
    .blueprint-active-badge {
      position: absolute;
      top: 8px;
      right: 8px;
      background: #4ECDC4;
      color: #000;
      font-size: 9px;
      font-weight: 600;
      padding: 3px 8px;
      border-radius: 10px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .blueprint-default-badge {
      font-size: 9px;
      color: #888;
      background: rgba(255,255,255,0.1);
      padding: 2px 6px;
      border-radius: 4px;
      margin-left: auto;
    }
    
    .blueprint-state-badge {
      font-size: 10px;
      margin-left: 4px;
      opacity: 0.7;
    }
    
    .blueprint-description {
      font-size: 11px;
      color: #888;
      line-height: 1.4;
      margin-bottom: 8px;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
    }
    
    .blueprint-description.expanded {
      -webkit-line-clamp: unset;
      display: block;
    }
    
    .blueprint-duplicate-btn {
      background: rgba(167, 139, 250, 0.15);
      border: 1px solid rgba(167, 139, 250, 0.3);
      color: #A78BFA;
      padding: 6px 10px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 11px;
      line-height: 1;
      transition: all 0.15s;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    
    .blueprint-duplicate-btn:hover,
    .blueprint-duplicate-btn:active {
      background: rgba(167, 139, 250, 0.3);
    }
    
    /* Blueprint card in edit mode */
    .blueprint-card.edit-mode {
      border-color: rgba(255, 165, 77, 0.3);
    }
    
    .blueprint-modal-actions {
      margin-top: 20px;
      padding-top: 16px;
      border-top: 1px solid rgba(255,255,255,0.1);
      display: flex;
      justify-content: center;
    }
    
    .blueprint-save-btn {
      background: rgba(78, 205, 196, 0.15);
      border: 1px solid rgba(78, 205, 196, 0.3);
      color: #4ECDC4;
      padding: 10px 20px;
      border-radius: 10px;
      cursor: pointer;
      font-family: 'Space Mono', monospace;
      font-size: 12px;
      transition: all 0.2s;
      -webkit-tap-highlight-color: transparent;
    }
    
    .blueprint-save-btn:hover {
      background: rgba(78, 205, 196, 0.25);
    }
    
    .blueprint-save-btn:active {
      transform: scale(0.98);
    }
    
    /* Blueprint button in header */
    .blueprint-btn {
      background: linear-gradient(135deg, rgba(78, 205, 196, 0.2), rgba(69, 183, 209, 0.2));
      border: 1px solid rgba(78, 205, 196, 0.3);
      color: #4ECDC4;
      padding: 8px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-family: 'Space Mono', monospace;
      font-size: 11px;
      transition: all 0.2s;
      -webkit-tap-highlight-color: transparent;
    }
    
    .blueprint-btn:hover {
      background: linear-gradient(135deg, rgba(78, 205, 196, 0.3), rgba(69, 183, 209, 0.3));
      border-color: rgba(78, 205, 196, 0.5);
    }
    
    /* Blueprint import button */
    .blueprint-import-btn {
      background: rgba(255, 165, 77, 0.15);
      border: 1px solid rgba(255, 165, 77, 0.3);
      color: #FFA94D;
      padding: 10px 20px;
      border-radius: 10px;
      cursor: pointer;
      font-family: 'Space Mono', monospace;
      font-size: 12px;
      transition: all 0.2s;
      -webkit-tap-highlight-color: transparent;
    }
    
    .blueprint-import-btn:hover {
      background: rgba(255, 165, 77, 0.25);
    }
    
    /* Blueprint card export button */
    .blueprint-export-btn {
      background: rgba(130, 224, 170, 0.15);
      border: 1px solid rgba(130, 224, 170, 0.3);
      color: #82E0AA;
      padding: 6px 10px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 11px;
      line-height: 1;
      transition: all 0.15s;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    
    .blueprint-export-btn:hover,
    .blueprint-export-btn:active {
      background: rgba(130, 224, 170, 0.3);
    }
    
    /* Blueprint card actions row */
    .blueprint-card-actions {
      display: flex;
      gap: 8px;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(255,255,255,0.06);
    }
    
    /* Add Folder from Blueprint button in library header */
    .add-from-blueprint-btn {
      background: rgba(255, 165, 77, 0.15);
      border: 1px solid rgba(255, 165, 77, 0.3);
      color: #FFA94D;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-family: 'Space Mono', monospace;
      font-size: 10px;
      transition: all 0.2s;
      margin-top: 10px;
      width: 100%;
      -webkit-tap-highlight-color: transparent;
    }
    
    .add-from-blueprint-btn:hover {
      background: rgba(255, 165, 77, 0.25);
    }
    
    /* Recently Deleted / Trash Section */
    .trash-section {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid rgba(255,255,255,0.1);
    }
    
    .trash-toggle-btn {
      background: rgba(255, 100, 100, 0.1);
      border: 1px solid rgba(255, 100, 100, 0.2);
      color: #ff6b6b;
      padding: 10px 16px;
      border-radius: 10px;
      cursor: pointer;
      font-family: 'Space Mono', monospace;
      font-size: 12px;
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      transition: all 0.2s;
    }
    
    .trash-toggle-btn:hover {
      background: rgba(255, 100, 100, 0.15);
    }
    
    .trash-toggle-btn .trash-arrow {
      transition: transform 0.2s;
    }
    
    .trash-toggle-btn.expanded .trash-arrow {
      transform: rotate(90deg);
    }
    
    .trash-content {
      display: none;
      margin-top: 12px;
    }
    
    .trash-content.expanded {
      display: block;
    }
    
    .trash-empty {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 20px;
      color: #666;
    }
    
    .trash-empty-icon {
      font-size: 28px;
      opacity: 0.5;
    }
    
    .trash-empty-text {
      font-size: 12px;
    }
    
    .trash-header-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    
    .trash-count {
      font-size: 11px;
      color: #888;
    }
    
    .trash-empty-btn {
      background: rgba(255, 100, 100, 0.15);
      border: 1px solid rgba(255, 100, 100, 0.3);
      color: #ff6b6b;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 10px;
      cursor: pointer;
      transition: all 0.15s;
    }
    
    .trash-empty-btn:hover {
      background: rgba(255, 100, 100, 0.25);
    }
    
    .trash-items {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 200px;
      overflow-y: auto;
    }
    
    .trash-item {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      padding: 10px 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
    }
    
    .trash-item-info {
      display: flex;
      align-items: center;
      gap: 10px;
      flex: 1;
      min-width: 0;
    }
    
    .trash-item-icon {
      font-size: 20px;
      flex-shrink: 0;
    }
    
    .trash-item-details {
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-width: 0;
    }
    
    .trash-item-name {
      font-size: 12px;
      color: #fff;
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .trash-item-type {
      font-size: 10px;
      color: #666;
    }
    
    .trash-item-meta {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
    }
    
    .trash-item-expires {
      font-size: 9px;
      color: #FFA94D;
      white-space: nowrap;
    }
    
    .trash-item-actions {
      display: flex;
      gap: 4px;
    }
    
    .trash-restore-btn {
      background: rgba(78, 205, 196, 0.15);
      border: 1px solid rgba(78, 205, 196, 0.3);
      color: #4ECDC4;
      padding: 4px 8px;
      border-radius: 5px;
      font-size: 10px;
      cursor: pointer;
      transition: all 0.15s;
      white-space: nowrap;
    }
    
    .trash-restore-btn:hover {
      background: rgba(78, 205, 196, 0.25);
    }
    
    .trash-delete-btn {
      background: rgba(255, 100, 100, 0.15);
      border: 1px solid rgba(255, 100, 100, 0.3);
      color: #ff6b6b;
      padding: 4px 8px;
      border-radius: 5px;
      font-size: 10px;
      cursor: pointer;
      transition: all 0.15s;
    }
    
    .trash-delete-btn:hover {
      background: rgba(255, 100, 100, 0.25);
    }
    
    @media (max-width: 600px) {
      .trash-item {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
      }
      
      .trash-item-meta {
        width: 100%;
        justify-content: space-between;
      }
    }
    
    /* Settings Panel */
    .settings-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      z-index: 4999;
      display: none;
    }
    
    .settings-overlay.active {
      display: block;
    }
    
    .settings-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #1a1a2e;
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 20px;
      padding: 24px;
      z-index: 5000;
      box-shadow: 0 30px 80px rgba(0,0,0,0.8);
      display: none;
      max-width: 90vw;
      max-height: 85vh;
      width: 450px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }
    
    .settings-modal.active {
      display: block;
    }
    
    .settings-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    
    .settings-header h3 {
      font-family: 'Syne', sans-serif;
      font-size: 18px;
      color: #fff;
      margin: 0;
    }
    
    .settings-close-btn {
      background: rgba(255,255,255,0.1);
      border: none;
      color: #888;
      width: 32px;
      height: 32px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 18px;
      transition: all 0.15s;
    }
    
    .settings-close-btn:hover {
      background: rgba(255,255,255,0.2);
      color: #fff;
    }
    
    .settings-section {
      margin-bottom: 24px;
    }
    
    .settings-section:last-child {
      margin-bottom: 0;
    }
    
    .settings-section-title {
      font-size: 12px;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .settings-section-title .section-icon {
      font-size: 14px;
    }
    
    .settings-api-row {
      display: flex;
      align-items: center;
      gap: 10px;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 12px;
      margin-bottom: 8px;
    }
    
    .settings-api-label {
      font-size: 12px;
      color: #fff;
      min-width: 80px;
    }
    
    .settings-api-status {
      flex: 1;
      font-size: 11px;
      font-family: 'Space Mono', monospace;
    }
    
    .settings-api-status.set {
      color: #4ECDC4;
    }
    
    .settings-api-status.not-set {
      color: #888;
    }
    
    .settings-api-btn {
      background: rgba(78, 205, 196, 0.15);
      border: 1px solid rgba(78, 205, 196, 0.3);
      color: #4ECDC4;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.15s;
    }
    
    .settings-api-btn:hover {
      background: rgba(78, 205, 196, 0.25);
    }
    
    .settings-api-btn.remove {
      background: rgba(255, 100, 100, 0.15);
      border-color: rgba(255, 100, 100, 0.3);
      color: #ff6b6b;
    }
    
    .settings-api-btn.remove:hover {
      background: rgba(255, 100, 100, 0.25);
    }
    
    .settings-api-input-row {
      display: none;
      gap: 8px;
      margin-top: 8px;
    }
    
    .settings-api-input-row.active {
      display: flex;
    }
    
    .settings-api-input {
      flex: 1;
      background: rgba(0,0,0,0.3);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 8px;
      padding: 10px 12px;
      color: #fff;
      font-family: 'Space Mono', monospace;
      font-size: 11px;
    }
    
    .settings-api-save-btn {
      background: #4ECDC4;
      border: none;
      color: #000;
      padding: 10px 16px;
      border-radius: 8px;
      font-weight: 600;
      font-size: 11px;
      cursor: pointer;
    }
    
    .settings-radio-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .settings-radio-option {
      display: flex;
      align-items: center;
      gap: 12px;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 12px;
      cursor: pointer;
      transition: all 0.15s;
    }
    
    .settings-radio-option:hover {
      border-color: rgba(78, 205, 196, 0.3);
    }
    
    .settings-radio-option.selected {
      border-color: #4ECDC4;
      background: rgba(78, 205, 196, 0.1);
    }
    
    .settings-radio-circle {
      width: 18px;
      height: 18px;
      border: 2px solid #555;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    
    .settings-radio-option.selected .settings-radio-circle {
      border-color: #4ECDC4;
    }
    
    .settings-radio-circle::after {
      content: '';
      width: 8px;
      height: 8px;
      background: #4ECDC4;
      border-radius: 50%;
      display: none;
    }
    
    .settings-radio-option.selected .settings-radio-circle::after {
      display: block;
    }
    
    .settings-radio-content {
      flex: 1;
    }
    
    .settings-radio-title {
      font-size: 12px;
      color: #fff;
      margin-bottom: 2px;
    }
    
    .settings-radio-desc {
      font-size: 10px;
      color: #666;
    }
    
    .settings-theme-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }
    
    .settings-theme-option {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      padding: 12px 8px;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.15s;
    }
    
    .settings-theme-option:hover {
      border-color: rgba(78, 205, 196, 0.3);
    }
    
    .settings-theme-option.selected {
      border-color: #4ECDC4;
      background: rgba(78, 205, 196, 0.1);
    }
    
    .settings-theme-option.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .settings-theme-preview {
      width: 40px;
      height: 28px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .settings-theme-name {
      font-size: 10px;
      color: #888;
    }
    
    .settings-danger-zone {
      background: rgba(255, 100, 100, 0.05);
      border: 1px solid rgba(255, 100, 100, 0.15);
      border-radius: 12px;
      padding: 16px;
    }
    
    .settings-danger-title {
      font-size: 11px;
      color: #ff6b6b;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .settings-danger-btn {
      display: flex;
      align-items: center;
      gap: 10px;
      width: 100%;
      background: rgba(255, 100, 100, 0.1);
      border: 1px solid rgba(255, 100, 100, 0.2);
      border-radius: 8px;
      padding: 12px;
      color: #ff6b6b;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.15s;
      margin-bottom: 8px;
      text-align: left;
    }
    
    .settings-danger-btn:last-child {
      margin-bottom: 0;
    }
    
    .settings-danger-btn:hover {
      background: rgba(255, 100, 100, 0.2);
    }
    
    .settings-danger-btn .danger-icon {
      font-size: 16px;
    }
    
    .settings-danger-btn .danger-text {
      flex: 1;
    }
    
    .settings-danger-btn .danger-desc {
      font-size: 10px;
      color: #888;
      margin-top: 2px;
    }

    /* Add Folder Modal */
    .add-folder-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      z-index: 2999;
      display: none;
    }
    
    .add-folder-overlay.active {
      display: block;
    }
    
    .add-folder-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #1a1a2e;
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 20px;
      padding: 24px;
      z-index: 3000;
      box-shadow: 0 30px 80px rgba(0,0,0,0.8);
      display: none;
      max-width: 90vw;
      max-height: 85vh;
      width: 500px;
      overflow: hidden;
    }
    
    .add-folder-modal.active {
      display: block;
    }
    
    .add-folder-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    
    .add-folder-modal-header h3 {
      font-family: 'Syne', sans-serif;
      font-size: 18px;
      color: #fff;
      margin: 0;
    }
    
    .add-folder-modal-description {
      font-size: 12px;
      color: #666;
      margin-bottom: 20px;
    }
    
    .add-folder-grid {
      max-height: 60vh;
      overflow-y: auto;
    }
    
    .add-folder-blueprint-section {
      margin-bottom: 20px;
    }
    
    .add-folder-blueprint-title {
      font-family: 'Syne', sans-serif;
      font-size: 13px;
      color: #888;
      margin-bottom: 10px;
      padding-bottom: 6px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    
    .add-folder-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    
    .add-folder-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 12px;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.15s;
      -webkit-tap-highlight-color: transparent;
    }
    
    .add-folder-item:hover {
      background: rgba(255,255,255,0.08);
      border-color: rgba(78, 205, 196, 0.3);
    }
    
    .add-folder-item:active {
      transform: scale(0.98);
    }
    
    .add-folder-item.already-added {
      opacity: 0.4;
      cursor: not-allowed;
    }
    
    .add-folder-item-icon {
      font-size: 14px;
    }
    
    .add-folder-item-label {
      font-size: 11px;
      color: #ccc;
    }
    
    .add-folder-item-badge {
      font-size: 9px;
      color: #666;
      background: rgba(255,255,255,0.05);
      padding: 2px 6px;
      border-radius: 4px;
      margin-left: 4px;
    }
    
    .category-phrases {
      padding: 10px;
      background: rgba(15, 15, 24, 0.95);
      border: 1px solid rgba(255,255,255,0.05);
      border-top: none;
      border-radius: 0 0 8px 8px;
      display: none;
      flex-direction: column;
      gap: 6px;
    }
    
    .category-phrases.expanded {
      display: flex;
    }
    
    /* Phrase chips */
    .phrase-chip {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-left: 3px solid var(--chip-color, #888);
      border-radius: 6px;
      font-size: 11px;
      line-height: 1.4;
      transition: all 0.15s;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      -webkit-touch-callout: none;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      position: relative;
    }
    
    .phrase-chip .chip-icon,
    .phrase-chip .chip-text {
      pointer-events: none;
      user-select: none;
      -webkit-user-select: none;
    }
    
    .phrase-chip:hover {
      background: rgba(255,255,255,0.06);
      transform: translateX(2px);
    }
    
    .phrase-chip:active {
      transform: scale(0.97);
      background: rgba(78, 205, 196, 0.1);
    }
    
    .phrase-chip.selected {
      background: rgba(78, 205, 196, 0.15);
      border-color: #4ECDC4;
      box-shadow: 0 0 12px rgba(78, 205, 196, 0.3);
      transform: scale(1.02);
    }
    
    .phrase-chip.pressing {
      transform: scale(0.95);
      background: rgba(78, 205, 196, 0.1);
      border-color: #4ECDC4;
    }
    
    .phrase-chip.picked-up {
      opacity: 0.4;
      transform: scale(0.95);
    }
    
    /* Edit mode wiggle animation */
    @keyframes wiggle {
      0%, 100% { transform: rotate(-0.5deg); }
      50% { transform: rotate(0.5deg); }
    }
    
    .library-panel.edit-mode .phrase-chip:not(.in-slot) {
      animation: wiggle 0.15s ease-in-out infinite;
    }
    
    .library-panel.edit-mode .phrase-chip:nth-child(even):not(.in-slot) {
      animation-delay: 0.075s;
    }
    
    /* Phrase delete button (edit mode) */
    .phrase-delete {
      display: none !important;
      position: absolute;
      top: -6px;
      right: -6px;
      width: 18px;
      height: 18px;
      background: #FF6B6B;
      border: 2px solid #0f0f18;
      border-radius: 50%;
      color: #fff;
      font-size: 10px;
      cursor: pointer;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    
    .library-panel.edit-mode .phrase-delete {
      display: flex !important;
    }
    
    .chip-icon {
      font-size: 12px;
      flex-shrink: 0;
    }
    
    .chip-text {
      flex: 1;
      color: #ccc;
    }
    
    .chip-remove {
      background: none;
      border: none;
      color: #666;
      cursor: pointer;
      font-size: 14px;
      padding: 0 4px;
      line-height: 1;
      transition: color 0.2s;
      display: none;
    }
    
    .phrase-chip.in-slot .chip-remove {
      display: block;
    }
    
    .chip-remove:hover {
      color: #FF6B6B;
    }
    
    .add-phrase-btn {
      background: none;
      border: 1px dashed rgba(255,255,255,0.1);
      color: #666;
      padding: 8px;
      border-radius: 6px;
      cursor: pointer;
      font-family: 'Space Mono', monospace;
      font-size: 10px;
      transition: all 0.2s;
      width: 100%;
    }
    
    .add-phrase-btn:hover {
      border-color: rgba(255,255,255,0.3);
      color: #aaa;
    }
    
    .add-phrase-form {
      display: none;
      gap: 6px;
    }
    
    .add-phrase-form.active {
      display: flex;
    }
    
    .add-phrase-form input {
      flex: 1;
      background: rgba(0,0,0,0.3);
      border: 1px solid rgba(255,255,255,0.1);
      color: #fff;
      padding: 8px 10px;
      border-radius: 4px;
      font-family: 'Space Mono', monospace;
      font-size: 11px;
    }
    
    .add-phrase-form input:focus {
      outline: none;
      border-color: #4ECDC4;
    }
    
    .add-phrase-form button {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      color: #aaa;
      padding: 8px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-family: 'Space Mono', monospace;
      font-size: 10px;
    }
    
    .add-phrase-form button:hover {
      background: rgba(255,255,255,0.1);
      color: #fff;
    }
    
    /* Builder Panel */
    .builder-panel {
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background: linear-gradient(180deg, #0d0d14 0%, #0a0a0f 100%);
    }
    
    .builder-header {
      padding: 14px 20px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
    }
    
    .builder-header h2 {
      font-family: 'Syne', sans-serif;
      font-size: 15px;
      font-weight: 600;
    }
    
    .clear-btn {
      background: rgba(255,107,107,0.1);
      border: 1px solid rgba(255,107,107,0.2);
      color: #FF6B6B;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-family: 'Space Mono', monospace;
      font-size: 10px;
      transition: all 0.2s;
    }
    
    .clear-btn:hover {
      background: rgba(255,107,107,0.2);
    }
    
    /* Reference images */
    .ref-images-section {
      padding: 14px 20px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      flex-shrink: 0;
    }
    
    .ref-images-header {
      font-size: 11px;
      color: #888;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .ref-images-grid {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    
    .ref-image-slot {
      width: 75px;
      height: 95px;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      flex-shrink: 0;
      -webkit-tap-highlight-color: transparent;
    }
    
    .ref-image-slot.empty {
      border: 2px dashed rgba(255,255,255,0.15);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
      touch-action: manipulation;
      -webkit-user-select: none;
      user-select: none;
    }
    
    /* Label-based empty slots need explicit dimensions */
    label.ref-image-slot.empty {
      width: 75px;
      height: 95px;
      box-sizing: border-box;
    }
    
    .ref-image-slot.empty:hover,
    .ref-image-slot.empty:active {
      border-color: rgba(78, 205, 196, 0.5);
      background: rgba(78, 205, 196, 0.05);
    }
    
    .ref-add-icon {
      font-size: 20px;
      color: #555;
    }
    
    .ref-add-text {
      font-size: 8px;
      color: #555;
      margin-top: 4px;
      text-align: center;
    }
    
    .ref-image-slot.filled {
      border: 2px solid rgba(78, 205, 196, 0.3);
    }
    
    .ref-image-preview {
      width: 100%;
      height: 55px;
      object-fit: cover;
      display: block;
    }
    
    .ref-role-select {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.85);
      border: none;
      color: #fff;
      padding: 5px 2px;
      font-family: 'Space Mono', monospace;
      font-size: 8px;
      cursor: pointer;
      text-align: center;
    }
    
    .ref-remove {
      position: absolute;
      top: 3px;
      right: 3px;
      background: rgba(0,0,0,0.8);
      border: none;
      color: #fff;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.2s;
    }
    
    .ref-image-slot:hover .ref-remove {
      opacity: 1;
    }
    
    .ref-remove:hover {
      background: #FF6B6B;
    }
    
    /* Slots */
    .slots-container {
      flex: 1;
      overflow-y: auto;
      padding: 14px 20px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      -webkit-overflow-scrolling: touch;
    }
    
    .prompt-slot {
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 8px;
      overflow: hidden;
      transition: all 0.2s;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      flex-shrink: 0;
    }
    
    .prompt-slot.drag-over,
    .prompt-slot.tap-ready {
      border-color: var(--slot-color, #4ECDC4);
      box-shadow: 0 0 20px rgba(78, 205, 196, 0.15);
    }
    
    .prompt-slot.tap-ready .slot-header {
      filter: brightness(1.2);
    }
    
    .prompt-slot.tap-ready .slot-placeholder {
      color: #4ECDC4;
    }
    
    .prompt-slot.drag-hover {
      border-color: var(--slot-color) !important;
      box-shadow: 0 0 30px rgba(78, 205, 196, 0.2);
      transform: scale(1.01);
    }
    
    .prompt-slot.drag-hover .slot-header {
      filter: brightness(1.3);
    }
    
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      75% { transform: translateX(5px); }
    }
    
    .prompt-slot.invalid-drop {
      animation: shake 0.3s ease-in-out;
    }
    
    .slot-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      transition: all 0.2s;
    }
    
    .slot-icon {
      font-size: 12px;
    }
    
    .slot-label {
      font-size: 10px;
      font-weight: 600;
      color: #aaa;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .slot-content {
      padding: 10px;
      min-height: 44px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-content: flex-start;
    }
    
    .slot-placeholder {
      color: #444;
      font-size: 10px;
      font-style: italic;
      width: 100%;
      text-align: center;
      padding: 6px;
    }
    
    /* Preview Panel */
    .preview-panel {
      background: #0f0f18;
      border-left: 1px solid rgba(255,255,255,0.05);
      display: flex;
      flex-direction: column;
      position: relative; /* For absolute positioned assistant panel */
      overflow: hidden;
    }
    
    .preview-header {
      padding: 12px 16px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      display: flex;
      flex-direction: column;
      gap: 10px;
      flex-shrink: 0;
    }
    
    .preview-header h2 {
      font-family: 'Syne', sans-serif;
      font-size: 14px;
      font-weight: 600;
      margin: 0;
    }
    
    .preview-actions {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    
    /* Compact action buttons */
    .preview-actions button {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
      padding: 8px 12px;
      border-radius: 8px;
      font-family: 'Space Mono', monospace;
      font-size: 9px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      min-width: 60px;
    }
    
    .preview-actions button .btn-icon {
      font-size: 18px;
      line-height: 1;
    }
    
    .preview-actions button .btn-label {
      font-size: 9px;
      opacity: 0.9;
    }
    
    /* Action button base styles */
    .action-btn {
      border: 1px solid;
      background: transparent;
    }
    
    .action-btn:hover {
      transform: translateY(-1px);
    }
    
    .action-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      transform: none !important;
    }
    
    /* Copy button */
    .copy-btn {
      background: linear-gradient(135deg, rgba(78, 205, 196, 0.15), rgba(69, 183, 209, 0.15));
      border-color: rgba(78, 205, 196, 0.4);
      color: #4ECDC4;
    }
    
    .copy-btn:hover {
      background: linear-gradient(135deg, rgba(78, 205, 196, 0.25), rgba(69, 183, 209, 0.25));
      box-shadow: 0 4px 12px rgba(78, 205, 196, 0.2);
    }
    
    .copy-btn.copied {
      background: rgba(130, 224, 170, 0.2);
      border-color: rgba(130, 224, 170, 0.5);
      color: #82E0AA;
    }
    
    .preview-content {
      flex: 1;
      margin: 0;
      padding: 16px;
      background: rgba(0,0,0,0.3);
      color: #ccc;
      font-size: 11px;
      line-height: 1.8;
      overflow-y: auto;
      white-space: pre-wrap;
      word-break: break-word;
      font-family: 'Space Mono', monospace;
    }
    
    .preview-content.empty {
      color: #444;
      font-style: italic;
    }
    
    /* Color-coded preview phrases */
    .preview-phrase {
      font-weight: 500;
    }
    
    .preview-label {
      color: #888;
      font-weight: 400;
    }
    
    .preview-sep {
      color: #555;
    }
    
    .preview-ref {
      color: #888;
      font-style: italic;
    }
    
    /* Template bar */
    .template-bar {
      padding: 12px 16px;
      border-top: 1px solid rgba(255,255,255,0.05);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(0,0,0,0.2);
      flex-shrink: 0;
      flex-wrap: wrap;
      gap: 10px;
    }
    
    .template-current {
      font-size: 11px;
      color: #888;
    }
    
    .template-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    
    .template-actions button {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      color: #aaa;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-family: 'Space Mono', monospace;
      font-size: 10px;
      transition: all 0.2s;
    }
    
    .template-actions button:hover {
      background: rgba(255,255,255,0.1);
      color: #fff;
    }
    
    .template-select {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      color: #aaa;
      padding: 6px 12px;
      border-radius: 6px;
      font-family: 'Space Mono', monospace;
      font-size: 10px;
      cursor: pointer;
    }
    
    .save-form {
      display: none;
      gap: 6px;
    }
    
    .save-form.active {
      display: flex;
    }
    
    .save-form input {
      background: rgba(0,0,0,0.3);
      border: 1px solid rgba(255,255,255,0.1);
      color: #fff;
      padding: 6px 10px;
      border-radius: 4px;
      font-family: 'Space Mono', monospace;
      font-size: 10px;
      width: 130px;
    }
    
    .save-form input:focus {
      outline: none;
      border-color: #4ECDC4;
    }
    
    /* Hidden file input */
    .hidden-input {
      position: absolute;
      width: 0;
      height: 0;
      opacity: 0;
      overflow: hidden;
      z-index: -1;
    }
    
    /* Toast notification */
    .toast {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.8);
      background: linear-gradient(135deg, #4ECDC4, #45B7D1);
      color: #000;
      padding: 16px 32px;
      border-radius: 12px;
      font-family: 'Syne', sans-serif;
      font-size: 16px;
      font-weight: 700;
      box-shadow: 0 10px 40px rgba(78, 205, 196, 0.5);
      z-index: 3000;
      opacity: 0;
      pointer-events: none;
      transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    
    .toast.show {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }
    
    .toast.hide {
      opacity: 0;
      transform: translate(-50%, -50%) scale(0.8) translateY(-20px);
    }
    
    /* Drag ghost */
    .drag-ghost {
      position: fixed;
      pointer-events: none;
      z-index: 2000;
      padding: 8px 12px;
      background: rgba(78, 205, 196, 0.9);
      border: 2px solid #4ECDC4;
      border-radius: 8px;
      font-size: 11px;
      font-family: 'Space Mono', monospace;
      color: #000;
      font-weight: 600;
      box-shadow: 0 8px 32px rgba(78, 205, 196, 0.5);
      transform: translate(-50%, -50%) scale(1.05);
      max-width: 180px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      transition: transform 0.1s, opacity 0.15s;
    }
    
    .drag-ghost.dropping {
      transform: translate(-50%, -50%) scale(0.9);
      opacity: 0;
    }
    
    /* Modal for creating folder */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2500;
    }
    
    .modal-overlay.active {
      display: flex;
    }
    
    .modal {
      background: #1a1a2e;
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      padding: 24px;
      width: 320px;
      max-width: 90vw;
    }
    
    .modal h3 {
      font-family: 'Syne', sans-serif;
      font-size: 18px;
      margin-bottom: 16px;
      color: #fff;
    }
    
    .modal input {
      width: 100%;
      padding: 12px;
      background: rgba(0,0,0,0.3);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 6px;
      color: #fff;
      font-family: 'Space Mono', monospace;
      font-size: 13px;
      margin-bottom: 12px;
    }
    
    .modal input:focus {
      outline: none;
      border-color: #4ECDC4;
    }
    
    .modal-actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }
    
    .modal-actions button {
      padding: 10px 20px;
      border-radius: 6px;
      font-family: 'Space Mono', monospace;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .modal-actions .cancel-btn {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      color: #aaa;
    }
    
    .modal-actions .confirm-btn {
      background: linear-gradient(135deg, #4ECDC4, #45B7D1);
      border: none;
      color: #000;
      font-weight: 700;
    }
    
    .modal label {
      display: block;
      font-size: 11px;
      color: #888;
      margin-bottom: 6px;
    }
    
    .emoji-picker {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 16px;
    }
    
    .emoji-option {
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      background: rgba(255,255,255,0.05);
      border: 2px solid transparent;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.15s;
    }
    
    .emoji-option:hover {
      background: rgba(255,255,255,0.1);
    }
    
    .emoji-option.selected {
      border-color: #4ECDC4;
      background: rgba(78, 205, 196, 0.1);
    }
    
    /* Scrollbar */
    ::-webkit-scrollbar {
      width: 6px;
    }
    
    ::-webkit-scrollbar-track {
      background: rgba(255,255,255,0.02);
    }
    
    ::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.1);
      border-radius: 3px;
    }
    
    ::-webkit-scrollbar-thumb:hover {
      background: rgba(255,255,255,0.15);
    }
    
    /* Responsive */
    @media (max-width: 1100px) {
      .app-main {
        grid-template-columns: 280px 1fr 320px;
      }
    }
    
    @media (max-width: 900px) {
      .app-main {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr auto;
        height: auto;
      }
      
      .library-panel {
        max-height: 280px;
        border-right: none;
        border-bottom: 1px solid rgba(255,255,255,0.05);
      }
      
      .preview-panel {
        border-left: none;
        border-top: 1px solid rgba(255,255,255,0.05);
      }
      
      .preview-content {
        min-height: 180px;
      }
    }
    
    @media (min-width: 900px) and (max-height: 750px) {
      .slot-header {
        padding: 6px 10px;
      }
      
      .slot-content {
        padding: 8px;
        min-height: 38px;
      }
      
      .slots-container {
        gap: 6px;
        padding: 10px 16px;
      }
      
      .ref-images-section {
        padding: 10px 16px;
      }
      
      .ref-image-slot {
        width: 65px;
        height: 85px;
      }
      
      .ref-image-preview {
        height: 48px;
      }
    }
    
    /* ============ IMAGE GENERATOR (Nano Banana Pro) ============ */
    .image-gen-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      z-index: 3000;
      display: none;
    }
    
    .image-gen-overlay.active {
      display: block;
    }
    
    .image-gen-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.95);
      background: linear-gradient(145deg, #1a1a2e 0%, #0f0f1a 100%);
      border: 1px solid rgba(255, 200, 50, 0.3);
      border-radius: 16px;
      width: 95vw;
      max-width: 1100px;
      height: 85vh;
      max-height: 700px;
      z-index: 3001;
      display: none;
      flex-direction: column;
      overflow: hidden;
      box-shadow: 0 25px 80px rgba(0, 0, 0, 0.7), 0 0 60px rgba(255, 200, 50, 0.1);
      opacity: 0;
      transition: all 0.3s ease;
    }
    
    .image-gen-modal.active {
      display: flex;
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }
    
    .image-gen-header {
      padding: 16px 20px;
      background: linear-gradient(90deg, rgba(255, 200, 50, 0.15) 0%, transparent 100%);
      border-bottom: 1px solid rgba(255, 200, 50, 0.2);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .image-gen-header h3 {
      font-family: 'Syne', sans-serif;
      font-size: 18px;
      font-weight: 700;
      color: #FFD700;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .image-gen-close {
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: #888;
      width: 32px;
      height: 32px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 20px;
      transition: all 0.2s;
    }
    
    .image-gen-close:hover {
      background: rgba(255, 100, 100, 0.2);
      color: #ff6b6b;
    }
    
    .image-gen-body {
      display: flex;
      flex: 1;
      overflow: hidden;
    }
    
    .image-gen-controls {
      width: 320px;
      padding: 20px;
      border-right: 1px solid rgba(255, 255, 255, 0.05);
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    
    .image-gen-api-setup {
      background: rgba(255, 200, 50, 0.1);
      border: 1px solid rgba(255, 200, 50, 0.2);
      border-radius: 12px;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .image-gen-api-setup h4 {
      color: #FFD700;
      font-size: 14px;
      margin: 0;
    }
    
    .image-gen-api-setup p {
      color: #888;
      font-size: 11px;
      line-height: 1.5;
      margin: 0;
    }
    
    .image-gen-api-input-group {
      display: flex;
      gap: 8px;
    }
    
    .image-gen-api-input {
      flex: 1;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      padding: 10px 12px;
      color: #fff;
      font-family: 'Space Mono', monospace;
      font-size: 12px;
    }
    
    .image-gen-api-save {
      background: linear-gradient(135deg, #FFD700, #FFA500);
      border: none;
      color: #000;
      padding: 10px 16px;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
    }
    
    .image-gen-api-link {
      color: #FFD700;
      font-size: 11px;
      text-decoration: none;
    }
    
    .image-gen-settings {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }
    
    .image-gen-setting label {
      display: block;
      font-size: 11px;
      color: #888;
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .image-gen-select, .image-gen-setting select {
      width: 100%;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 10px 12px;
      color: #fff;
      font-family: 'Space Mono', monospace;
      font-size: 12px;
      cursor: pointer;
    }
    
    .image-gen-prompt-preview {
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 12px;
      font-size: 11px;
      color: #aaa;
      max-height: 100px;
      overflow-y: auto;
      line-height: 1.6;
      white-space: pre-wrap;
      word-break: break-word;
    }
    
    /* Color-coded prompt spans in preview */
    .image-gen-prompt-preview span {
      font-weight: 500;
    }
    
    .batch-selector {
      display: flex;
      gap: 8px;
    }
    
    .batch-option {
      flex: 1;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: #888;
      padding: 10px;
      border-radius: 8px;
      cursor: pointer;
      font-family: 'Space Mono', monospace;
      font-size: 12px;
      transition: all 0.2s;
    }
    
    .batch-option.selected {
      background: rgba(255, 200, 50, 0.2);
      border-color: rgba(255, 200, 50, 0.5);
      color: #FFD700;
    }
    
    .image-gen-submit {
      width: 100%;
      background: linear-gradient(135deg, #FFD700, #FFA500);
      border: none;
      color: #000;
      padding: 14px;
      border-radius: 10px;
      font-family: 'Syne', sans-serif;
      font-size: 14px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .image-gen-submit:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .image-gen-gallery {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
    }
    
    .gallery-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      flex-wrap: wrap;
      gap: 10px;
      flex-shrink: 0;
    }
    
    .gallery-header-left {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }
    
    .gallery-header h4 {
      color: #fff;
      font-size: 14px;
      margin: 0;
    }
    
    .gallery-storage-indicator {
      font-size: 11px;
      color: #4ECDC4;
      background: rgba(78, 205, 196, 0.1);
      padding: 4px 10px;
      border-radius: 12px;
      white-space: nowrap;
    }
    
    .gallery-controls {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .gallery-size-control {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .gallery-size-control .size-icon {
      font-size: 14px;
      opacity: 0.6;
    }
    
    .gallery-size-control input[type="range"] {
      width: 100px;
      height: 4px;
      -webkit-appearance: none;
      appearance: none;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 2px;
      cursor: pointer;
    }
    
    .gallery-size-control input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: #FFC857;
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.15s;
    }
    
    .gallery-size-control input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.2);
    }
    
    .gallery-clear-btn {
      background: rgba(255, 100, 100, 0.1);
      border: 1px solid rgba(255, 100, 100, 0.3);
      color: #ff6b6b;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 10px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .gallery-clear-btn:hover {
      background: rgba(255, 100, 100, 0.2);
    }
    
    /* Gallery grid - Apple Photos-like fluid layout */
    .gallery-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(var(--gallery-item-size, 150px), 1fr));
      gap: 8px;
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 8px;
      -webkit-overflow-scrolling: touch; /* Smooth momentum scrolling on iOS */
      scroll-behavior: smooth;
      align-content: start;
    }
    
    .gallery-empty {
      grid-column: 1 / -1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 60px 40px;
      color: #555;
    }
    
    .gallery-empty-icon {
      font-size: 48px;
      margin-bottom: 12px;
    }
    
    .image-card {
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      cursor: pointer;
      /* Smooth transitions for layout changes */
      transition: transform 0.15s ease-out, box-shadow 0.15s ease-out, opacity 0.2s ease;
    }
    
    .image-card:hover {
      transform: scale(1.02);
      box-shadow: 0 4px 20px rgba(0,0,0,0.4);
    }
    
    .image-card:active {
      transform: scale(0.98);
    }
    
    /* Images display at natural aspect ratio - NO cropping */
    .image-card img {
      width: 100%;
      height: auto;
      display: block;
      /* Smooth image loading */
      opacity: 1;
      transition: opacity 0.2s ease;
    }
    
    /* Loading placeholder with dynamic aspect ratio */
    .image-card-loading {
      background: rgba(255, 200, 87, 0.05);
      border-color: rgba(255, 200, 87, 0.2);
    }
    
    .loading-placeholder {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 28px;
      color: rgba(255, 200, 87, 0.6);
      animation: pulse 1.5s infinite ease-in-out;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 0.4; }
      50% { opacity: 1; }
    }
    
    /* Error placeholder */
    .image-card-error {
      background: rgba(255, 100, 100, 0.05);
      border-color: rgba(255, 100, 100, 0.2);
    }
    
    .error-placeholder {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 16px 12px;
      color: #ff6b6b;
      font-size: 11px;
      text-align: center;
      line-height: 1.4;
    }
    
    .error-placeholder .error-icon {
      font-size: 24px;
    }
    
    .error-placeholder .error-text {
      opacity: 0.8;
    }
    
    .error-delete-btn {
      background: rgba(255, 100, 100, 0.2);
      border: 1px solid rgba(255, 100, 100, 0.3);
      color: #ff6b6b;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 10px;
      cursor: pointer;
      margin-top: 4px;
      transition: all 0.15s;
    }
    
    .error-delete-btn:hover {
      background: rgba(255, 100, 100, 0.3);
    }
    
    .error-delete-btn:active {
      transform: scale(0.95);
    }
    
    .image-card-actions {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 8px;
      background: linear-gradient(transparent, rgba(0,0,0,0.9));
      display: flex;
      gap: 6px;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.2s;
    }
    
    .image-card:hover .image-card-actions,
    .image-card:active .image-card-actions {
      opacity: 1;
    }
    
    .image-card-btn {
      background: rgba(255, 255, 255, 0.15);
      border: 1px solid rgba(255,255,255,0.2);
      color: #fff;
      width: 32px;
      height: 32px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
    }
    
    .image-card-btn:hover {
      background: rgba(255, 255, 255, 0.3);
    }
    
    /* Touch device support - always show actions */
    @media (hover: none) {
      .image-card-actions {
        opacity: 1;
        background: linear-gradient(transparent 0%, rgba(0,0,0,0.7) 100%);
      }
    }
    
    /* ============ IMAGE LIGHTBOX ============ */
    .lightbox-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.97);
      z-index: 5000;
      display: none;
      flex-direction: column;
      touch-action: none;
    }
    
    .lightbox-overlay.active {
      display: flex;
    }
    
    .lightbox-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      background: rgba(0, 0, 0, 0.5);
      flex-shrink: 0;
    }
    
    .lightbox-info {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 13px;
      color: rgba(255, 255, 255, 0.9);
    }
    
    .lightbox-settings {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.5);
    }
    
    .lightbox-close-btn {
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: #fff;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }
    
    .lightbox-close-btn:hover {
      background: rgba(255, 100, 100, 0.3);
    }
    
    .lightbox-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      position: relative;
    }
    
    /* Navigation arrows */
    .lightbox-nav {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: #fff;
      width: 50px;
      height: 80px;
      cursor: pointer;
      font-size: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      z-index: 10;
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
    }
    
    .lightbox-nav:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    
    .lightbox-nav:disabled {
      opacity: 0.2;
      cursor: not-allowed;
    }
    
    .lightbox-nav-prev {
      left: 0;
      border-radius: 0 12px 12px 0;
    }
    
    .lightbox-nav-next {
      right: 0;
      border-radius: 12px 0 0 12px;
    }
    
    .lightbox-image-wrapper {
      position: relative;
      transform-origin: center center;
      transition: transform 0.1s ease-out;
    }
    
    .lightbox-image {
      max-width: 85vw;
      max-height: 70vh;
      object-fit: contain;
      border-radius: 8px;
      box-shadow: 0 8px 40px rgba(0, 0, 0, 0.5);
      transition: opacity 0.15s ease;
    }
    
    .lightbox-hint {
      position: absolute;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 11px;
      color: rgba(255, 255, 255, 0.6);
      pointer-events: none;
      opacity: 1;
      transition: opacity 0.3s;
    }
    
    .lightbox-hint.hidden {
      opacity: 0;
    }
    
    /* Bottom action bar */
    .lightbox-actions {
      display: flex;
      justify-content: center;
      gap: 8px;
      padding: 16px;
      background: rgba(0, 0, 0, 0.5);
      flex-shrink: 0;
    }
    
    .lightbox-action-btn {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.15);
      color: #fff;
      padding: 10px 16px;
      border-radius: 10px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      transition: all 0.2s;
      min-width: 70px;
    }
    
    .lightbox-action-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-2px);
    }
    
    .lightbox-action-btn:active {
      transform: scale(0.95);
    }
    
    .lightbox-action-btn .action-icon {
      font-size: 20px;
    }
    
    .lightbox-action-btn .action-label {
      font-size: 10px;
      opacity: 0.8;
    }
    
    .lightbox-action-btn.delete-btn {
      background: rgba(255, 80, 80, 0.15);
      border-color: rgba(255, 80, 80, 0.25);
    }
    
    .lightbox-action-btn.delete-btn:hover {
      background: rgba(255, 80, 80, 0.3);
    }
    
    /* ============ CLAUDE ASSISTANT PANEL ============ */
    .assistant-panel {
      display: none;
      flex-direction: column;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #0f0f18;
      z-index: 10;
      overflow: hidden;
    }
    
    .assistant-panel.active {
      display: flex;
    }
    
    .assistant-header {
      padding: 12px 16px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .assistant-header h3 {
      font-family: 'Syne', sans-serif;
      font-size: 14px;
      color: #fff;
    }
    
    .assistant-close-btn {
      background: rgba(255,255,255,0.1);
      border: none;
      color: #888;
      width: 28px;
      height: 28px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
    }
    
    .api-key-setup {
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .api-key-setup h4 {
      color: #4ECDC4;
      font-size: 14px;
      margin: 0;
    }
    
    .api-key-setup p {
      color: #888;
      font-size: 11px;
      line-height: 1.5;
      margin: 0;
    }
    
    .api-key-input-group {
      display: flex;
      gap: 8px;
    }
    
    .api-key-input {
      flex: 1;
      background: rgba(0,0,0,0.3);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 6px;
      padding: 10px;
      color: #fff;
      font-family: 'Space Mono', monospace;
      font-size: 12px;
    }
    
    .api-key-save-btn {
      background: #4ECDC4;
      border: none;
      color: #000;
      padding: 10px 16px;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
    }
    
    .api-key-link {
      color: #4ECDC4;
      font-size: 11px;
    }
    
    .assistant-messages {
      flex: 1;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-height: 0; /* Important for flex scroll containment */
    }
    
    .assistant-message {
      padding: 12px 14px;
      border-radius: 12px;
      font-size: 12px;
      line-height: 1.6;
      max-width: 95%;
    }
    
    .assistant-message.user {
      background: rgba(78, 205, 196, 0.15);
      border: 1px solid rgba(78, 205, 196, 0.3);
      color: #ccc;
      align-self: flex-end;
    }
    
    .assistant-message.assistant, .assistant-message.system {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      color: #ccc;
      align-self: flex-start;
    }
    
    /* Animated typing indicator */
    .typing-indicator {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 16px 18px;
    }
    
    .typing-indicator span {
      width: 8px;
      height: 8px;
      background: #4ECDC4;
      border-radius: 50%;
      animation: typingBounce 1.4s infinite ease-in-out;
    }
    
    .typing-indicator span:nth-child(1) { animation-delay: 0s; }
    .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
    .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }
    
    @keyframes typingBounce {
      0%, 60%, 100% { 
        transform: translateY(0);
        opacity: 0.4;
      }
      30% { 
        transform: translateY(-8px);
        opacity: 1;
      }
    }
    
    .assistant-input-area {
      padding: 12px;
      border-top: 1px solid rgba(255,255,255,0.05);
    }
    
    .assistant-input-wrapper {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
    }
    
    .assistant-input {
      flex: 1;
      background: rgba(0,0,0,0.3);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      padding: 10px;
      color: #fff;
      font-family: 'Space Mono', monospace;
      font-size: 12px;
      resize: none;
    }
    
    .assistant-send-btn {
      background: #4ECDC4;
      border: none;
      color: #000;
      padding: 10px 16px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
    }
    
    .assistant-suggestions {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 10px;
    }
    
    .suggestion-chip {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      color: #888;
      padding: 6px 10px;
      border-radius: 20px;
      font-size: 10px;
      cursor: pointer;
    }
    
    .assistant-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    
    .assistant-model-select {
      background: rgba(78, 205, 196, 0.15);
      border: 1px solid rgba(78, 205, 196, 0.3);
      color: #4ECDC4;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 10px;
      cursor: pointer;
      flex-shrink: 0;
    }
    
    .assistant-model-select:focus {
      outline: none;
      border-color: #4ECDC4;
    }
    
    .assistant-action-btn {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      color: #888;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 10px;
      cursor: pointer;
    }
    
    /* ============ ASSISTANT ACTION BLOCKS ============ */
    .action-block {
      background: rgba(255, 200, 87, 0.08);
      border: 1px solid rgba(255, 200, 87, 0.25);
      border-radius: 10px;
      padding: 12px;
      margin-top: 10px;
    }
    
    .action-block-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
      font-size: 11px;
      color: #FFC857;
      font-weight: 600;
    }
    
    .action-block-content {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 6px;
      padding: 10px;
      font-size: 11px;
      color: #aaa;
      max-height: 120px;
      overflow-y: auto;
      margin-bottom: 10px;
      font-family: 'Space Mono', monospace;
      white-space: pre-wrap;
    }
    
    .action-block-preview {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 6px;
      padding: 10px;
      margin-bottom: 10px;
    }
    
    .action-block-preview-label {
      font-size: 9px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 6px;
    }
    
    .action-block-phrases {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }
    
    .action-block-phrase {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 10px;
      color: #ccc;
    }
    
    .action-block-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    
    .action-btn-apply {
      background: linear-gradient(135deg, #FFC857, #FFA94D);
      border: none;
      color: #000;
      padding: 10px 16px;
      border-radius: 8px;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.2s;
    }
    
    .action-btn-apply:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(255, 200, 87, 0.3);
    }
    
    .action-btn-secondary {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #ccc;
      padding: 10px 16px;
      border-radius: 8px;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .action-btn-secondary:hover {
      background: rgba(255, 255, 255, 0.15);
    }
    
    /* Folder selector in action block */
    .action-folder-select {
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.15);
      color: #fff;
      padding: 8px 10px;
      border-radius: 6px;
      font-size: 11px;
      margin-bottom: 10px;
      width: 100%;
    }
    
    /* Blueprint preview in action block */
    .blueprint-preview {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 6px;
      margin-bottom: 10px;
    }
    
    .blueprint-preview-folder {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 6px;
      padding: 8px;
      text-align: center;
    }
    
    .blueprint-preview-folder-icon {
      font-size: 16px;
      margin-bottom: 4px;
    }
    
    .blueprint-preview-folder-name {
      font-size: 9px;
      color: #888;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .blueprint-preview-folder-count {
      font-size: 8px;
      color: #555;
    }

    /* Generate button - primary action */
    .generate-btn {
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.9), rgba(255, 165, 0, 0.9));
      border-color: rgba(255, 200, 87, 0.6);
      color: #000;
    }
    
    .generate-btn:hover:not(:disabled) {
      box-shadow: 0 4px 16px rgba(255, 200, 87, 0.4);
    }
    
    /* Chat toggle button */
    .chat-toggle-btn {
      background: rgba(78, 205, 196, 0.1);
      border-color: rgba(78, 205, 196, 0.3);
      color: #4ECDC4;
    }
    
    .chat-toggle-btn:hover {
      background: rgba(78, 205, 196, 0.2);
    }
    
    .chat-toggle-btn.active {
      background: rgba(78, 205, 196, 0.3);
      border-color: #4ECDC4;
    }
    
    /* Gallery button */
    .gallery-btn {
      background: rgba(147, 112, 219, 0.1);
      border-color: rgba(147, 112, 219, 0.3);
      color: #9370DB;
    }
    
    .gallery-btn:hover {
      background: rgba(147, 112, 219, 0.2);
      border-color: rgba(147, 112, 219, 0.5);
    }
    
    /* ============ VISION CHAT MODAL ============ */
    .vision-chat-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      z-index: 3100;
      display: none;
    }
    
    .vision-chat-overlay.active {
      display: block;
    }
    
    .vision-chat-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.95);
      background: linear-gradient(145deg, #1a1a2e 0%, #0f0f1a 100%);
      border: 1px solid rgba(187, 143, 206, 0.3);
      border-radius: 16px;
      width: 95vw;
      max-width: 900px;
      height: 80vh;
      max-height: 600px;
      z-index: 3101;
      display: none;
      flex-direction: column;
      overflow: hidden;
      box-shadow: 0 25px 80px rgba(0, 0, 0, 0.7);
      opacity: 0;
      transition: all 0.3s ease;
    }
    
    .vision-chat-modal.active {
      display: flex;
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }
    
    .vision-chat-header {
      padding: 14px 20px;
      background: linear-gradient(90deg, rgba(187, 143, 206, 0.15) 0%, transparent 100%);
      border-bottom: 1px solid rgba(187, 143, 206, 0.2);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .vision-chat-header h3 {
      font-family: 'Syne', sans-serif;
      font-size: 16px;
      font-weight: 700;
      color: #BB8FCE;
    }
    
    .vision-chat-close {
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: #888;
      width: 32px;
      height: 32px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 20px;
    }
    
    .vision-chat-body {
      display: flex;
      flex: 1;
      overflow: hidden;
    }
    
    .vision-chat-image {
      width: 300px;
      padding: 16px;
      border-right: 1px solid rgba(255, 255, 255, 0.05);
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .vision-chat-image img {
      width: 100%;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .vision-chat-prompt {
      font-size: 10px;
      color: #888;
      line-height: 1.5;
      max-height: 80px;
      overflow-y: auto;
    }
    
    .vision-chat-prompt-label {
      font-size: 9px;
      color: #666;
      text-transform: uppercase;
      margin-bottom: 4px;
    }
    
    .vision-chat-conversation {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    .vision-chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .vision-chat-message {
      padding: 12px 14px;
      border-radius: 12px;
      font-size: 12px;
      line-height: 1.6;
      max-width: 90%;
    }
    
    .vision-chat-message.user {
      background: rgba(187, 143, 206, 0.15);
      border: 1px solid rgba(187, 143, 206, 0.3);
      color: #ccc;
      align-self: flex-end;
    }
    
    .vision-chat-message.assistant {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: #ccc;
      align-self: flex-start;
    }
    
    .vision-chat-welcome {
      text-align: center;
      padding: 30px;
    }
    
    .vision-chat-welcome-icon {
      font-size: 40px;
      margin-bottom: 12px;
    }
    
    .vision-chat-welcome-text {
      color: #888;
      font-size: 13px;
      margin-bottom: 16px;
    }
    
    .vision-chat-welcome-suggestions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
    }
    
    .vision-chat-welcome-suggestions button {
      background: rgba(187, 143, 206, 0.1);
      border: 1px solid rgba(187, 143, 206, 0.3);
      color: #BB8FCE;
      padding: 8px 14px;
      border-radius: 20px;
      font-size: 11px;
      cursor: pointer;
    }
    
    .vision-chat-input-area {
      padding: 12px 16px;
      border-top: 1px solid rgba(255, 255, 255, 0.05);
      display: flex;
      gap: 10px;
    }
    
    .vision-chat-input-area textarea {
      flex: 1;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      padding: 10px 14px;
      color: #fff;
      font-family: 'Space Mono', monospace;
      font-size: 12px;
      resize: none;
    }
    
    .vision-chat-send {
      background: linear-gradient(135deg, #BB8FCE, #9B59B6);
      border: none;
      color: #fff;
      padding: 10px 20px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
    }
    
    .vision-chat-typing {
      display: flex;
      gap: 4px;
      padding: 12px;
      align-self: flex-start;
    }
    
    .vision-chat-typing span {
      width: 8px;
      height: 8px;
      background: #BB8FCE;
      border-radius: 50%;
      animation: typingBounce 1.4s infinite ease-in-out;
    }
    
    .vision-chat-typing span:nth-child(2) { animation-delay: 0.2s; }
    .vision-chat-typing span:nth-child(3) { animation-delay: 0.4s; }
    
    @media (max-width: 768px) {
      .image-gen-modal {
        width: 98vw;
        height: 90vh;
        max-height: none;
      }
      
      .image-gen-body {
        flex-direction: column;
      }
      
      .image-gen-controls {
        width: 100%;
        border-right: none;
        border-bottom: 1px solid rgba(255,255,255,0.05);
        max-height: 40vh;
      }
      
      .vision-chat-body {
        flex-direction: column;
      }
      
      .vision-chat-image {
        width: 100%;
        border-right: none;
        border-bottom: 1px solid rgba(255,255,255,0.05);
        max-height: 200px;
      }
    }
  </style>
</head>
<body>
  <header class="app-header">
    <div>
      <h1 class="app-title">üçå Prompt Blocks</h1>
      <p class="app-subtitle">v2.56 - Blueprint State & Actions</p>
    </div>
    <div class="header-actions">
      <button class="blueprint-btn" id="blueprintBtn" onclick="openBlueprintModal()">
        üë§ Portrait
      </button>
      <button class="edit-btn" id="editBtn" onclick="toggleEditMode()">
        ‚úçÔ∏è Edit
      </button>
      <button class="settings-btn" id="settingsBtn" onclick="openSettings()">
        ‚öôÔ∏è Settings
      </button>
    </div>
  </header>
  
  <main class="app-main">
    <!-- Library Panel -->
    <aside class="library-panel" id="libraryPanel">
      <div class="library-header">
        <h2>üìö Phrase Library</h2>
        <p class="library-subtitle">Hold + drag to slots</p>
        <div class="library-blueprint-actions">
          <button class="library-action-btn" onclick="openBlueprintModal()" title="Browse Blueprints">
            <span>üìã</span> Blueprints
          </button>
          <button class="library-action-btn" onclick="triggerBlueprintImport()" title="Import Blueprint">
            <span>üì§</span> Import
          </button>
          <button class="library-action-btn" onclick="saveCurrentAsBlueprint()" title="Save Current as Blueprint">
            <span>üíæ</span> Save
          </button>
        </div>
        <button class="add-from-blueprint-btn" onclick="openAddFolderModal()">üìÇ Add Folder from Blueprint</button>
      </div>
      <div class="library-categories" id="libraryCategories">
        <!-- Generated by JS -->
      </div>
      <div class="trash-bin" id="trashBin">
        <div class="trash-bin-target" id="trashBinTarget">
          <span class="trash-icon">üóëÔ∏è</span>
          Drop here to delete
        </div>
      </div>
    </aside>
    
    <!-- Builder Panel -->
    <section class="builder-panel">
      <div class="builder-header">
        <h2>üß± Build Your Prompt</h2>
        <button class="clear-btn" onclick="clearAllSlots()">Clear All</button>
      </div>
      
      <div class="ref-images-section">
        <div class="ref-images-header">üì∏ Reference Images</div>
        <div class="ref-images-grid" id="refImagesGrid">
          <!-- Generated by JS -->
        </div>
      </div>
      
      <div class="slots-container" id="slotsContainer">
        <!-- Generated by JS -->
      </div>
    </section>
    
    <!-- Preview Panel -->
    <aside class="preview-panel" id="previewPanel">
      <div class="preview-header">
        <h2 id="previewTitle">üìù Generated Prompt</h2>
        <div class="preview-actions">
          <button class="action-btn generate-btn" id="generateBtn" onclick="toggleImageGenerator()" disabled>
            <span class="btn-icon">üçå</span>
            <span class="btn-label">Generate</span>
          </button>
          <button class="action-btn gallery-btn" onclick="openGalleryOnly()">
            <span class="btn-icon">üñºÔ∏è</span>
            <span class="btn-label">Gallery</span>
          </button>
          <button class="action-btn chat-toggle-btn" id="chatToggleBtn" onclick="toggleAssistant()">
            <span class="btn-icon">ü§ñ</span>
            <span class="btn-label">Assistant</span>
          </button>
          <button class="action-btn copy-btn" id="copyBtn" onclick="copyPrompt()">
            <span class="btn-icon">üìã</span>
            <span class="btn-label">Copy</span>
          </button>
        </div>
      </div>
      <pre class="preview-content empty" id="previewContent">Start adding phrases to build your prompt...</pre>
      
      <!-- Claude Assistant Panel -->
      <div class="assistant-panel" id="assistantPanel">
        <div class="assistant-header">
          <h3>ü§ñ Claude Assistant</h3>
          <button class="assistant-close-btn" onclick="toggleAssistant()">√ó</button>
        </div>
        <div class="api-key-setup" id="apiKeySetup">
          <div>
            <h4>üîë API Key Required</h4>
            <p>To use Claude Assistant, you need an Anthropic API key.</p>
          </div>
          <div class="api-key-input-group">
            <input type="password" class="api-key-input" id="apiKeyInput" placeholder="sk-ant-...">
            <button class="api-key-save-btn" onclick="saveApiKey()">Save</button>
          </div>
          <a href="https://console.anthropic.com/settings/keys" target="_blank" class="api-key-link">Get API key ‚Üí</a>
        </div>
        <div class="assistant-messages" id="assistantMessages" style="display: none;">
          <div class="assistant-message system">üëã I'm your prompt engineering co-pilot! I can:<br><br>‚Ä¢ üé® <strong>Create blueprints</strong> for any photography style<br>‚Ä¢ ‚ûï <strong>Add phrases</strong> to your folders<br>‚Ä¢ ‚ú® <strong>Suggest prompts</strong> and improvements<br>‚Ä¢ üìÅ <strong>Build custom folders</strong><br><br>Try: "Create a wildlife photography blueprint"</div>
        </div>
        <div class="assistant-input-area" id="assistantInputArea" style="display: none;">
          <div class="assistant-input-wrapper">
            <textarea class="assistant-input" id="assistantInput" placeholder="Describe your idea..." rows="2"></textarea>
            <button class="assistant-send-btn" id="assistantSendBtn" onclick="sendToAssistant()">Send</button>
          </div>
          <div class="assistant-suggestions" id="assistantSuggestions">
            <button class="suggestion-chip" onclick="useSuggestion('Create a wildlife photography blueprint')">ü¶Å Wildlife</button>
            <button class="suggestion-chip" onclick="useSuggestion('Create a street photography blueprint')">üåÜ Street</button>
            <button class="suggestion-chip" onclick="useSuggestion('Add more lighting phrases')">üí° Lighting</button>
            <button class="suggestion-chip" onclick="useSuggestion('Improve my current prompt')">‚ú® Improve</button>
          </div>
          <div class="assistant-actions">
            <select class="assistant-model-select" id="assistantModelSelect" onchange="saveAssistantModel()">
              <option value="claude-3-haiku-20240307">‚ö° Haiku (Fast)</option>
              <option value="claude-3-5-sonnet-20241022">üèÉ Sonnet 3.5</option>
              <option value="claude-sonnet-4-20250514">üß† Sonnet 4</option>
              <option value="claude-3-opus-20240229">üéØ Opus (Smart)</option>
            </select>
            <button class="assistant-action-btn" onclick="useCurrentPrompt()">üìù Use prompt</button>
            <button class="assistant-action-btn" onclick="clearChat()">üóëÔ∏è Clear</button>
          </div>
        </div>
      </div>
      
      <div class="template-bar" id="templateBar">
        <div class="template-current" id="templateCurrent">üìÑ Untitled Prompt</div>
        <div class="template-actions">
          <div class="save-form" id="saveForm">
            <input type="text" id="saveNameInput" placeholder="Template name...">
            <button onclick="saveTemplate()">Save</button>
            <button onclick="hideSaveForm()">‚úï</button>
          </div>
          <button id="saveBtn" onclick="showSaveForm()">üíæ Save</button>
          <select class="template-select" id="templateSelect" onchange="loadTemplate(this.value)">
            <option value="">üìÇ Load...</option>
          </select>
        </div>
      </div>
    </aside>
  </main>
  
  <input type="file" accept="image/*" class="hidden-input" id="imageInput" onchange="handleImageSelect(event)">
  
  <div class="drag-ghost" id="dragGhost" style="display: none;"></div>
  
  <div class="toast" id="toast">‚úì Copied to clipboard!</div>
  
  <!-- Color picker modal (global) -->
  <div class="color-picker-overlay" id="colorPickerOverlay"></div>
  <div class="color-picker-popover" id="colorPickerModal">
    <div class="color-picker-title">Choose Color</div>
    <div class="color-picker-grid" id="colorPickerGrid">
      <!-- Generated by JS -->
    </div>
  </div>
  
  <!-- Modal for creating new folder -->
  <div class="modal-overlay" id="folderModal">
    <div class="modal">
      <h3>Create New Folder</h3>
      <label>Folder Name</label>
      <input type="text" id="newFolderName" placeholder="e.g., Backgrounds">
      <label>Icon</label>
      <div class="emoji-picker" id="emojiPicker">
        <div class="emoji-option selected" data-emoji="üìù">üìù</div>
        <div class="emoji-option" data-emoji="üé®">üé®</div>
        <div class="emoji-option" data-emoji="‚ú®">‚ú®</div>
        <div class="emoji-option" data-emoji="üåü">üåü</div>
        <div class="emoji-option" data-emoji="üîÆ">üîÆ</div>
        <div class="emoji-option" data-emoji="üé≠">üé≠</div>
        <div class="emoji-option" data-emoji="üåà">üåà</div>
        <div class="emoji-option" data-emoji="‚ö°">‚ö°</div>
        <div class="emoji-option" data-emoji="üî•">üî•</div>
        <div class="emoji-option" data-emoji="üí´">üí´</div>
        <div class="emoji-option" data-emoji="üéØ">üéØ</div>
        <div class="emoji-option" data-emoji="üí°">üí°</div>
      </div>
      <div class="modal-actions">
        <button class="cancel-btn" onclick="closeFolderModal()">Cancel</button>
        <button class="confirm-btn" onclick="createNewFolder()">Create</button>
      </div>
    </div>
  </div>
  
  <!-- Settings Modal -->
  <div class="settings-overlay" id="settingsOverlay" onclick="closeSettings()"></div>
  <div class="settings-modal" id="settingsModal">
    <div class="settings-header">
      <h3>‚öôÔ∏è Settings</h3>
      <button class="settings-close-btn" onclick="closeSettings()">√ó</button>
    </div>
    
    <!-- API Keys Section -->
    <div class="settings-section">
      <div class="settings-section-title">
        <span class="section-icon">üîë</span> API Keys
      </div>
      <div class="settings-api-row">
        <span class="settings-api-label">Anthropic</span>
        <span class="settings-api-status" id="settingsAnthropicStatus">Not set</span>
        <button class="settings-api-btn" id="settingsAnthropicBtn" onclick="toggleApiKeyInput('anthropic')">Add</button>
      </div>
      <div class="settings-api-input-row" id="anthropicInputRow">
        <input type="password" class="settings-api-input" id="settingsAnthropicInput" placeholder="sk-ant-...">
        <button class="settings-api-save-btn" onclick="saveSettingsApiKey('anthropic')">Save</button>
      </div>
      <div class="settings-api-row">
        <span class="settings-api-label">Google AI</span>
        <span class="settings-api-status" id="settingsGoogleStatus">Not set</span>
        <button class="settings-api-btn" id="settingsGoogleBtn" onclick="toggleApiKeyInput('google')">Add</button>
      </div>
      <div class="settings-api-input-row" id="googleInputRow">
        <input type="password" class="settings-api-input" id="settingsGoogleInput" placeholder="AIza...">
        <button class="settings-api-save-btn" onclick="saveSettingsApiKey('google')">Save</button>
      </div>
    </div>
    
    <!-- Generation Mode Section -->
    <div class="settings-section">
      <div class="settings-section-title">
        <span class="section-icon">üé®</span> Generation Mode
      </div>
      <div class="settings-radio-group">
        <div class="settings-radio-option selected" data-mode="sequential" onclick="setGenerationMode('sequential')">
          <div class="settings-radio-circle"></div>
          <div class="settings-radio-content">
            <div class="settings-radio-title">Sequential (Queue)</div>
            <div class="settings-radio-desc">Waits for current batch, then starts next</div>
          </div>
        </div>
        <div class="settings-radio-option" data-mode="parallel" onclick="setGenerationMode('parallel')">
          <div class="settings-radio-circle"></div>
          <div class="settings-radio-content">
            <div class="settings-radio-title">Parallel</div>
            <div class="settings-radio-desc">Multiple batches at once (uses more API quota)</div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Theme Section -->
    <div class="settings-section">
      <div class="settings-section-title">
        <span class="section-icon">üé≠</span> Theme
      </div>
      <div class="settings-theme-grid">
        <div class="settings-theme-option selected" data-theme="dark" onclick="setTheme('dark')">
          <div class="settings-theme-preview" style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);"></div>
          <span class="settings-theme-name">Dark</span>
        </div>
        <div class="settings-theme-option disabled" data-theme="light" title="Coming soon">
          <div class="settings-theme-preview" style="background: linear-gradient(135deg, #f5f5f5 0%, #e0e0e0 100%);"></div>
          <span class="settings-theme-name">Light</span>
        </div>
        <div class="settings-theme-option disabled" data-theme="oled" title="Coming soon">
          <div class="settings-theme-preview" style="background: #000;"></div>
          <span class="settings-theme-name">OLED Black</span>
        </div>
        <div class="settings-theme-option disabled" data-theme="matcha" title="Coming soon">
          <div class="settings-theme-preview" style="background: linear-gradient(135deg, #2d4a3e 0%, #1a2f25 100%);"></div>
          <span class="settings-theme-name">Matcha</span>
        </div>
        <div class="settings-theme-option disabled" data-theme="frutiger" title="Coming soon">
          <div class="settings-theme-preview" style="background: linear-gradient(135deg, #a8d8ea 0%, #aa96da 100%);"></div>
          <span class="settings-theme-name">Frutiger Aero</span>
        </div>
        <div class="settings-theme-option disabled" data-theme="vintage" title="Coming soon">
          <div class="settings-theme-preview" style="background: linear-gradient(135deg, #d4a574 0%, #8b6914 100%);"></div>
          <span class="settings-theme-name">Vintage</span>
        </div>
      </div>
    </div>
    
    <!-- Danger Zone -->
    <div class="settings-section">
      <div class="settings-danger-zone">
        <div class="settings-danger-title">
          ‚ö†Ô∏è Danger Zone
        </div>
        <button class="settings-danger-btn" onclick="resetBlueprintsToDefault()">
          <span class="danger-icon">üîÑ</span>
          <div class="danger-text">
            Reset Blueprints to Default
            <div class="danger-desc">Removes all custom blueprints and restores defaults</div>
          </div>
        </button>
        <button class="settings-danger-btn" onclick="clearAllData()">
          <span class="danger-icon">üóëÔ∏è</span>
          <div class="danger-text">
            Clear All Data & Cache
            <div class="danger-desc">Deletes everything including gallery, blueprints, and settings</div>
          </div>
        </button>
      </div>
    </div>
  </div>
  
  <!-- Blueprint modal -->
  <div class="blueprint-overlay" id="blueprintOverlay"></div>
  <div class="blueprint-modal" id="blueprintModal">
    <div class="blueprint-modal-header">
      <h3>üìã Blueprints</h3>
      <div class="blueprint-modal-header-actions">
        <button class="blueprint-edit-btn" id="blueprintEditBtn" onclick="toggleBlueprintEditMode()">‚úçÔ∏è Edit</button>
        <button class="blueprint-close-btn" onclick="closeBlueprintModal()">√ó</button>
      </div>
    </div>
    <div class="blueprint-modal-description">
      Choose a prompt structure template
    </div>
    <div class="blueprint-grid" id="blueprintGrid">
      <!-- Generated by JS -->
    </div>
    <div class="blueprint-modal-actions">
      <button class="blueprint-import-btn" onclick="triggerBlueprintImport()">üì§ Import Blueprint</button>
      <button class="blueprint-save-btn" onclick="saveCurrentAsBlueprint()">üíæ Save Current as Blueprint</button>
    </div>
    
    <!-- Recently Deleted Section -->
    <div class="trash-section">
      <button class="trash-toggle-btn" id="trashToggleBtn" onclick="toggleTrashSection()">
        <span>üóëÔ∏è Recently Deleted</span>
        <span class="trash-arrow">‚ñ∂</span>
      </button>
      <div class="trash-content" id="trashContent">
        <div id="trashSection">
          <!-- Generated by JS -->
        </div>
      </div>
    </div>
  </div>
  
  <!-- Add Folder from Blueprint modal -->
  <div class="add-folder-overlay" id="addFolderOverlay"></div>
  <div class="add-folder-modal" id="addFolderModal">
    <div class="add-folder-modal-header">
      <h3>üìÇ Add Folder from Blueprint</h3>
      <button class="blueprint-close-btn" onclick="closeAddFolderModal()">√ó</button>
    </div>
    <div class="add-folder-modal-description">
      Select a folder to add to your current structure
    </div>
    <div class="add-folder-grid" id="addFolderGrid">
      <!-- Generated by JS -->
    </div>
  </div>
  
  <!-- Hidden file input for blueprint import -->
  <input type="file" accept=".json" id="blueprintFileInput" style="display:none" onchange="handleBlueprintImport(event)">

  <!-- Image Generator Modal (Nano Banana Pro) -->
  <div class="image-gen-overlay" id="imageGenOverlay" onclick="closeImageGenerator()"></div>
  <div class="image-gen-modal" id="imageGenModal">
    <div class="image-gen-header">
      <h3>üçå <span>Nano Banana Pro</span></h3>
      <button class="image-gen-close" onclick="closeImageGenerator()">√ó</button>
    </div>
    <div class="image-gen-body">
      <div class="image-gen-controls">
        <div class="image-gen-api-setup" id="imageGenApiSetup">
          <h4>üîë Google API Key Required</h4>
          <p>Enter your Google AI Studio API key to generate images.</p>
          <div class="image-gen-api-input-group">
            <input type="password" class="image-gen-api-input" id="googleApiKeyInput" placeholder="AIza...">
            <button class="image-gen-api-save" onclick="saveGoogleApiKey()">Save</button>
          </div>
          <a href="https://aistudio.google.com/app/apikey" target="_blank" class="image-gen-api-link">Get API key ‚Üí</a>
        </div>
        <div class="image-gen-settings" id="imageGenSettings" style="display: none;">
          <div class="image-gen-setting">
            <label>Prompt Preview</label>
            <div class="image-gen-prompt-preview" id="imageGenPromptPreview">Build your prompt...</div>
          </div>
          <div class="image-gen-setting">
            <label>Model</label>
            <select class="image-gen-select" id="modelSelect">
              <option value="gemini-3-pro-image-preview">üçå Nano Banana Pro (Quality)</option>
              <option value="gemini-2.5-flash-image">‚ö° Nano Banana (Fast)</option>
            </select>
          </div>
          <div class="image-gen-setting">
            <label>Aspect Ratio</label>
            <select class="image-gen-select" id="aspectRatioSelect">
              <option value="1:1">1:1 Square</option>
              <option value="16:9">16:9 Landscape</option>
              <option value="9:16">9:16 Portrait</option>
              <option value="4:3">4:3 Standard</option>
              <option value="3:4" selected>3:4 Portrait</option>
              <option value="3:2">3:2 Photo</option>
              <option value="2:3">2:3 Portrait</option>
            </select>
          </div>
          <div class="image-gen-setting">
            <label>Resolution</label>
            <select class="image-gen-select" id="resolutionSelect">
              <option value="1K">1K (1024px)</option>
              <option value="2K" selected>2K (2048px)</option>
              <option value="4K">4K (4096px)</option>
            </select>
          </div>
          <div class="image-gen-setting">
            <label>Batch Size</label>
            <div class="batch-selector">
              <button class="batch-option selected" data-count="1" onclick="selectBatchSize(1)">1√ó</button>
              <button class="batch-option" data-count="2" onclick="selectBatchSize(2)">2√ó</button>
              <button class="batch-option" data-count="4" onclick="selectBatchSize(4)">4√ó</button>
            </div>
          </div>
        </div>
        <div id="imageGenActions" style="display: none;">
          <button class="image-gen-submit" id="imageGenSubmit" onclick="generateImages()">üé® Generate Images</button>
        </div>
      </div>
      <div class="image-gen-gallery">
        <div class="gallery-header">
          <div class="gallery-header-left">
            <h4>üì∏ Generated Images</h4>
            <span class="gallery-storage-indicator" id="galleryStorageIndicator">üìä Loading...</span>
          </div>
          <div class="gallery-controls">
            <div class="gallery-size-control">
              <span class="size-icon">üîç</span>
              <input type="range" id="gallerySizeSlider" min="80" max="300" value="150" oninput="updateGallerySize(this.value)">
            </div>
            <button class="gallery-clear-btn" onclick="clearGallery()">Clear All</button>
          </div>
        </div>
        <div class="gallery-grid" id="galleryGrid">
          <div class="gallery-empty">
            <div class="gallery-empty-icon">üçå</div>
            <div class="gallery-empty-text">No images yet</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Vision Chat Modal -->
  <div class="vision-chat-overlay" id="visionChatOverlay" onclick="closeVisionChat()"></div>
  <div class="vision-chat-modal" id="visionChatModal">
    <div class="vision-chat-header">
      <h3>üí¨ Chat About Image</h3>
      <button class="vision-chat-close" onclick="closeVisionChat()">√ó</button>
    </div>
    <div class="vision-chat-body">
      <div class="vision-chat-image">
        <img id="visionChatImage" src="" alt="Image">
        <div class="vision-chat-image-info">
          <div class="vision-chat-prompt-label">Original Prompt:</div>
          <div class="vision-chat-prompt" id="visionChatPrompt"></div>
        </div>
      </div>
      <div class="vision-chat-conversation">
        <div class="vision-chat-messages" id="visionChatMessages">
          <div class="vision-chat-welcome">
            <div class="vision-chat-welcome-icon">üîç</div>
            <div class="vision-chat-welcome-text">Ask me about this image!</div>
            <div class="vision-chat-welcome-suggestions">
              <button onclick="sendVisionSuggestion('Describe this image')">Describe</button>
              <button onclick="sendVisionSuggestion('What could be improved?')">Improve</button>
              <button onclick="sendVisionSuggestion('Write a better prompt')">Better prompt</button>
            </div>
          </div>
        </div>
        <div class="vision-chat-input-area">
          <textarea id="visionChatInput" placeholder="Ask about the image..." rows="2"></textarea>
          <button class="vision-chat-send" onclick="sendVisionMessage()">Send</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Image Lightbox (Fullscreen Viewer with Pinch-to-Zoom) -->
  <div class="lightbox-overlay" id="lightboxOverlay">
    <div class="lightbox-header">
      <div class="lightbox-info" id="lightboxInfo">
        <span id="lightboxCounter">1 / 1</span>
        <span class="lightbox-settings" id="lightboxSettings">1:1 ‚Ä¢ 1K</span>
      </div>
      <button class="lightbox-close-btn" onclick="closeLightbox()">‚úï</button>
    </div>
    
    <div class="lightbox-container" id="lightboxContainer">
      <!-- Navigation arrows -->
      <button class="lightbox-nav lightbox-nav-prev" id="lightboxPrev" onclick="navigateLightbox(-1)">‚Äπ</button>
      
      <div class="lightbox-image-wrapper" id="lightboxWrapper">
        <img class="lightbox-image" id="lightboxImage" src="" alt="Full size image">
      </div>
      
      <button class="lightbox-nav lightbox-nav-next" id="lightboxNext" onclick="navigateLightbox(1)">‚Ä∫</button>
      
      <div class="lightbox-hint" id="lightboxHint">Pinch to zoom ‚Ä¢ Double-tap to reset</div>
    </div>
    
    <!-- Bottom action bar -->
    <div class="lightbox-actions">
      <button class="lightbox-action-btn" onclick="loadPromptFromImage()">
        <span class="action-icon">üîÑ</span>
        <span class="action-label">Load Prompt</span>
      </button>
      <button class="lightbox-action-btn" onclick="openVisionChatFromLightbox()">
        <span class="action-icon">üí¨</span>
        <span class="action-label">Chat</span>
      </button>
      <button class="lightbox-action-btn" onclick="shareImage()">
        <span class="action-icon">üì§</span>
        <span class="action-label">Share</span>
      </button>
      <button class="lightbox-action-btn" onclick="downloadLightboxImage()">
        <span class="action-icon">üíæ</span>
        <span class="action-label">Save</span>
      </button>
      <button class="lightbox-action-btn delete-btn" onclick="deleteFromLightbox()">
        <span class="action-icon">üóëÔ∏è</span>
        <span class="action-label">Delete</span>
      </button>
    </div>
  </div>

  <script>
    // ============ DATA ============
    const DEFAULT_CATEGORIES = [
      { id: 'instruction', label: 'Instruction', icon: 'üìù', color: '#74B9FF' },
      { id: 'subject', label: 'Subject', icon: 'üë§', color: '#FF6B6B' },
      { id: 'pose', label: 'Pose / Action', icon: 'üé≠', color: '#4ECDC4' },
      { id: 'environment', label: 'Environment', icon: 'üåç', color: '#45B7D1' },
      { id: 'camera', label: 'Camera', icon: 'üì∑', color: '#BB8FCE' },
      { id: 'lighting', label: 'Lighting', icon: 'üí°', color: '#F7DC6F' },
      { id: 'color', label: 'Color Palette', icon: 'üé®', color: '#FFA94D' },
      { id: 'style', label: 'Style', icon: 'üñºÔ∏è', color: '#85C1E9' },
      { id: 'mood', label: 'Mood', icon: '‚ú®', color: '#F1948A' },
      { id: 'constraints', label: 'Constraints', icon: 'üîí', color: '#82E0AA' },
      { id: 'quality', label: 'Quality', icon: 'üíé', color: '#D7BDE2' }
    ];
    
    const DEFAULT_PHRASES = {
      instruction: [
        "Generate a photograph of",
        "Create a cinematic still of",
        "Produce a professional portrait of",
        "Render a hyper-realistic image of",
        "Design a conceptual image featuring",
        "Capture a candid moment of"
      ],
      subject: [
        // People - Specific
        "A confident man in his late 20s",
        "A woman with striking angular features",
        "An elderly person with weathered hands and kind eyes",
        "A curious child with wide, wondering eyes",
        "A weathered fisherman with sun-creased face",
        "An elegant dancer frozen mid-movement",
        "A street musician lost in their melody",
        "Twin siblings in complementary outfits",
        // People - Generic/Placeholder
        "[Use reference image for identity]",
        "A solitary figure in silhouette",
        // Objects & Other
        "A vintage camera on worn leather",
        "An antique pocket watch, lid open",
        "Fresh flowers in morning dew",
        "A steaming cup of coffee"
      ],
      pose: [
        // Static poses
        "standing with arms crossed confidently",
        "seated, leaning forward intently",
        "leaning against weathered brick wall",
        "hands clasped behind back, contemplating",
        "sitting in quiet contemplation",
        // Dynamic poses
        "walking toward camera with purpose",
        "mid-gesture, hands expressive",
        "caught mid-laugh, head tilted back",
        "reaching toward soft light",
        "frozen in graceful motion",
        "looking over shoulder mysteriously",
        // Specific actions
        "adjusting collar, eyes downcast",
        "running fingers through hair",
        "holding object close to chest"
      ],
      environment: [
        // Urban
        "neon-lit Tokyo alley at night",
        "rain-slicked city street, reflections everywhere",
        "bustling night market, steam rising",
        "graffiti-covered underpass",
        "rooftop overlooking city skyline",
        "cozy corner of a vintage coffee shop",
        // Natural
        "sun-drenched Mediterranean courtyard",
        "fog-shrouded forest path at dawn",
        "serene mountain lake, mirror-still water",
        "golden wheat field at sunset",
        "rocky coastline with crashing waves",
        "bamboo forest with filtered light",
        // Studio/Interior
        "minimal white studio, clean backdrop",
        "moody dark studio with single light",
        "warmly lit library with leather chairs",
        "industrial loft with exposed brick",
        // Abstract/Atmospheric
        "abstract gradient background",
        "bokeh lights creating dreamy backdrop"
      ],
      camera: [
        // Lens & Settings
        "85mm portrait lens, f/1.4, creamy bokeh",
        "50mm standard, f/2.8, balanced depth",
        "35mm wide angle, f/8, deep focus",
        "24mm ultra-wide, dramatic perspective",
        "135mm telephoto, compressed background",
        "macro lens, extreme close-up detail",
        // Angles
        "eye level, direct connection",
        "low angle, looking up, powerful",
        "high angle, looking down, vulnerable",
        "Dutch angle, tilted, uneasy",
        "bird's eye view, overhead",
        "worm's eye view, ground level",
        // Framing
        "tight close-up on face",
        "medium shot, waist up",
        "full body with environment",
        "extreme wide establishing shot",
        "over-the-shoulder perspective"
      ],
      lighting: [
        // Natural light
        "golden hour, warm backlight",
        "soft diffused overcast, even tones",
        "harsh midday sun, strong shadows",
        "blue hour twilight, cool ambient",
        "dappled light through leaves",
        "window light from the side, soft falloff",
        // Artificial light
        "neon glow in cyan and magenta",
        "warm tungsten interior light",
        "harsh overhead spotlight, dramatic",
        "ring light, even facial lighting",
        "practical lights in frame",
        // Techniques
        "dramatic chiaroscuro, deep shadows",
        "Rembrandt lighting, triangle on cheek",
        "rim lighting, glowing edges",
        "split lighting, half shadow",
        "butterfly lighting, glamorous",
        // Mood-based
        "moody low-key, mostly shadows",
        "bright high-key, minimal shadows",
        "cinematic stormy lighting"
      ],
      color: [
        // Temperature
        "warm earth tones throughout",
        "cool blue shadows, warm highlights",
        "neutral balanced color palette",
        // Schemes
        "monochromatic, single hue variations",
        "complementary orange and teal",
        "analogous sunset warm hues",
        "triadic vibrant accents",
        // Specific palettes
        "muted desaturated, film-like",
        "rich saturated, punchy colors",
        "pastel soft, dreamy tones",
        "dark moody, deep shadows",
        // Film looks
        "Kodak Portra warm skin tones",
        "Fuji 400H green undertones",
        "Cinestill 800T tungsten shift"
      ],
      style: [
        // Photography styles
        "editorial portrait photography",
        "documentary photojournalism",
        "fine art conceptual",
        "commercial advertising",
        "street photography candid",
        "fashion editorial high-end",
        "lifestyle natural moments",
        // Film/Cinema
        "cinematic film still",
        "vintage 1970s film aesthetic",
        "noir high contrast drama",
        "indie film intimate feel",
        // Art references
        "Renaissance painting influence",
        "Dutch Golden Age lighting",
        "Impressionist soft edges",
        // Technical
        "shot on Hasselblad medium format",
        "35mm film grain texture",
        "large format sharp detail"
      ],
      mood: [
        // Positive
        "quiet confidence",
        "joyful exuberance",
        "peaceful serenity",
        "hopeful optimism",
        "warm nostalgia",
        "playful whimsy",
        // Intense
        "dramatic tension",
        "raw vulnerability",
        "powerful determination",
        "passionate intensity",
        // Contemplative
        "melancholic reflection",
        "wistful longing",
        "mysterious intrigue",
        "thoughtful solitude",
        // Atmospheric
        "ethereal dreamlike",
        "gritty authentic",
        "epic grandeur",
        "intimate connection"
      ],
      constraints: [
        // Identity preservation
        "MUST maintain exact facial features from reference",
        "MUST preserve subject's unique characteristics",
        // Realism requirements
        "MUST feel authentic, not AI-generated",
        "MUST have natural skin texture and pores",
        "MUST include subtle imperfections",
        "Avoid uncanny valley smoothness",
        "Maintain realistic body proportions",
        // Technical constraints
        "NEVER include text or watermarks",
        "NEVER add artificial lens flares",
        "Avoid over-sharpening artifacts",
        "No visible AI generation patterns",
        // Composition
        "Keep composition balanced",
        "Maintain clear focal point",
        "Ensure proper headroom in frame"
      ],
      quality: [
        // Resolution
        "photorealistic, indistinguishable from photograph",
        "8K resolution, extreme fine detail",
        "4K cinematic quality",
        // Technical excellence
        "tack sharp focus on subject",
        "professional color grading",
        "properly exposed, full dynamic range",
        // Film emulation
        "film grain, Kodak Portra 400",
        "Fujifilm Pro 400H emulation",
        "medium format film quality",
        // Printing
        "print-ready resolution",
        "gallery exhibition quality",
        "magazine cover worthy"
      ],
      // === PRODUCT BLUEPRINT ===
      product: [
        "sleek smartphone on marble surface",
        "luxury watch with metal bracelet",
        "minimalist perfume bottle",
        "artisan coffee bag, kraft paper",
        "premium headphones, matte black",
        "handcrafted ceramic mug",
        "organic skincare bottle",
        "vintage camera, brass details"
      ],
      surface: [
        "white marble with gray veins",
        "weathered wood planks",
        "brushed concrete",
        "black velvet fabric",
        "reflective glass surface",
        "natural linen texture",
        "terrazzo stone",
        "aged leather"
      ],
      background: [
        "seamless white infinity",
        "gradient gray to white",
        "soft colored gel backdrop",
        "natural environment, blurred",
        "architectural concrete wall",
        "lifestyle setting, home interior",
        "abstract texture backdrop",
        "pure black void"
      ],
      keylight: [
        "large softbox from 45√Ç¬∞ right",
        "beauty dish overhead",
        "strip light from side",
        "natural window light",
        "ring light frontal",
        "hard spotlight dramatic"
      ],
      filllight: [
        "reflector bounce from opposite side",
        "soft fill at 1/4 power",
        "ambient room light only",
        "negative fill (black card)",
        "subtle rim separation",
        "no fill, embrace shadows"
      ],
      // === LANDSCAPE BLUEPRINT ===
      location: [
        "misty mountain peaks",
        "coastal cliffs at sunrise",
        "endless desert dunes",
        "ancient forest canopy",
        "frozen arctic tundra",
        "tropical waterfall cascade",
        "rolling lavender fields",
        "volcanic landscape, steam rising"
      ],
      timeofday: [
        "golden hour, 1 hour before sunset",
        "blue hour, 30 min after sunset",
        "harsh midday sun",
        "soft overcast morning",
        "dramatic storm approaching",
        "milky way night sky",
        "first light at dawn"
      ],
      weather: [
        "clear skies, wispy clouds",
        "dramatic storm clouds",
        "morning fog lifting",
        "light rain, wet surfaces",
        "snow falling gently",
        "rainbow after storm",
        "dust in the air, hazy"
      ],
      atmosphere: [
        "ethereal and mystical",
        "crisp and clear",
        "hazy, dreamlike",
        "moody and dramatic",
        "fresh and vibrant",
        "ancient and timeless"
      ],
      composition: [
        "rule of thirds, subject left",
        "centered symmetry",
        "leading lines to horizon",
        "frame within frame",
        "negative space emphasis",
        "foreground interest",
        "layered depth planes"
      ],
      // === CINEMATIC BLUEPRINT ===
      scene: [
        "tense standoff moment",
        "quiet emotional revelation",
        "chase through narrow streets",
        "intimate conversation",
        "discovery of something hidden",
        "final confrontation"
      ],
      character: [
        "grizzled detective, weary eyes",
        "young rebel with hidden past",
        "elegant spy in formal wear",
        "weathered traveler seeking home",
        "brilliant scientist obsessed",
        "mysterious stranger arrives"
      ],
      action: [
        "turns to face the camera slowly",
        "reaches for something off-frame",
        "frozen mid-motion",
        "staring into distance",
        "reacting to sudden sound",
        "walking away, back to camera"
      ],
      setting: [
        "noir city streets, rain",
        "sun-bleached frontier town",
        "sleek futuristic interior",
        "war-torn urban ruins",
        "opulent mansion ballroom",
        "cramped submarine corridor"
      ],
      cinematography: [
        "Steadicam following shot",
        "handheld, documentary feel",
        "crane shot descending",
        "locked-off static frame",
        "slow push in",
        "tracking alongside subject"
      ],
      colorgrade: [
        "teal and orange blockbuster",
        "desaturated gritty look",
        "warm sepia nostalgic",
        "cold blue thriller",
        "neon-soaked cyberpunk",
        "natural film emulation"
      ],
      // === CONCEPT ART BLUEPRINT ===
      details: [
        "intricate armor engravings",
        "glowing magical runes",
        "battle damage and wear",
        "flowing fabric and hair",
        "otherworldly vegetation",
        "mechanical components visible"
      ],
      artstyle: [
        "painterly brushstrokes visible",
        "hyperrealistic rendering",
        "stylized anime influence",
        "classic oil painting technique",
        "graphic novel aesthetic",
        "art nouveau decorative"
      ],
      medium: [
        "digital painting",
        "oil on canvas texture",
        "watercolor washes",
        "pencil sketch refined",
        "3D render, Octane",
        "mixed media collage"
      ],
      reference: [
        "inspired by Frazetta",
        "Moebius linework influence",
        "Beksinski surrealism",
        "Studio Ghibli color palette",
        "Art Station trending style",
        "classic Rockwell composition"
      ],
      // === TEXT RENDER BLUEPRINT ===
      textcontent: [
        "\"HELLO\" in bold letters",
        "inspirational quote text",
        "vintage sign lettering",
        "neon sign glowing text",
        "handwritten script message",
        "graffiti style tag"
      ],
      fontstyle: [
        "bold sans-serif, modern",
        "elegant serif, classic",
        "hand-lettered, organic",
        "retro 70s display",
        "futuristic tech font",
        "weathered vintage type"
      ],
      placement: [
        "centered in frame",
        "bottom third, left aligned",
        "curved along path",
        "3D perspective receding",
        "scattered organic layout",
        "tight crop, partial letters"
      ],
      effects: [
        "glowing neon outline",
        "chrome metallic reflection",
        "deep embossed shadow",
        "distressed and worn",
        "liquid chrome dripping",
        "fire and smoke emanating"
      ],
      // === DUO SUBJECT BLUEPRINT ===
      subject1: [
        "protagonist, confident stance",
        "elder mentor figure",
        "young child, curious",
        "romantic lead, elegant"
      ],
      subject2: [
        "antagonist in shadow",
        "loyal companion beside",
        "mysterious stranger observing",
        "reflection in mirror"
      ],
      interaction: [
        "facing each other tensely",
        "back to back, united",
        "one reaching toward other",
        "separated by obstacle",
        "intimate embrace",
        "mid-conversation gesture"
      ]
    };
    
    const REFERENCE_ROLES = ['Identity', 'Composition', 'Lighting', 'Style', 'Full Recreation'];
    
    // ============ BLUEPRINTS ============
    // Pre-made prompt structures for different use cases
    const DEFAULT_BLUEPRINTS = [
      {
        id: 'portrait',
        name: 'Portrait',
        icon: 'üë§',
        description: 'People, headshots, character studies',
        categories: [
          { id: 'instruction', label: 'Instruction', icon: 'üìù', color: '#74B9FF' },
          { id: 'subject', label: 'Subject', icon: 'üë§', color: '#FF6B6B' },
          { id: 'pose', label: 'Pose / Action', icon: 'üé≠', color: '#4ECDC4' },
          { id: 'environment', label: 'Environment', icon: 'üåç', color: '#45B7D1' },
          { id: 'camera', label: 'Camera', icon: 'üì∑', color: '#BB8FCE' },
          { id: 'lighting', label: 'Lighting', icon: 'üí°', color: '#F7DC6F' },
          { id: 'color', label: 'Color Palette', icon: 'üé®', color: '#FFA94D' },
          { id: 'style', label: 'Style', icon: 'üñºÔ∏è', color: '#85C1E9' },
          { id: 'mood', label: 'Mood', icon: '‚ú®', color: '#F1948A' },
          { id: 'constraints', label: 'Constraints', icon: 'üîí', color: '#82E0AA' },
          { id: 'quality', label: 'Quality', icon: 'üíé', color: '#D7BDE2' }
        ]
      },
      {
        id: 'product',
        name: 'Product Shot',
        icon: 'üì¶',
        description: 'Commercial product photography',
        categories: [
          { id: 'instruction', label: 'Instruction', icon: 'üìù', color: '#74B9FF' },
          { id: 'product', label: 'Product', icon: 'üì¶', color: '#FF6B6B' },
          { id: 'surface', label: 'Surface / Props', icon: 'ü™µ', color: '#D4A574' },
          { id: 'background', label: 'Background', icon: 'üñºÔ∏è', color: '#45B7D1' },
          { id: 'keylight', label: 'Key Light', icon: '‚òÄÔ∏è', color: '#F7DC6F' },
          { id: 'filllight', label: 'Fill Light', icon: 'üí°', color: '#FFA94D' },
          { id: 'camera', label: 'Camera', icon: 'üì∑', color: '#BB8FCE' },
          { id: 'color', label: 'Color Palette', icon: 'üé®', color: '#85C1E9' },
          { id: 'style', label: 'Style', icon: '‚ú®', color: '#F1948A' },
          { id: 'quality', label: 'Quality', icon: 'üíé', color: '#D7BDE2' }
        ]
      },
      {
        id: 'landscape',
        name: 'Landscape',
        icon: 'üèîÔ∏è',
        description: 'Scenic vistas, nature, environments',
        categories: [
          { id: 'instruction', label: 'Instruction', icon: 'üìù', color: '#74B9FF' },
          { id: 'location', label: 'Location', icon: 'üìç', color: '#FF6B6B' },
          { id: 'timeofday', label: 'Time of Day', icon: 'üåÖ', color: '#FFA94D' },
          { id: 'weather', label: 'Weather', icon: 'üå§Ô∏è', color: '#74B9FF' },
          { id: 'atmosphere', label: 'Atmosphere', icon: 'üå´Ô∏è', color: '#A29BFE' },
          { id: 'composition', label: 'Composition', icon: 'üìê', color: '#4ECDC4' },
          { id: 'camera', label: 'Camera', icon: 'üì∑', color: '#BB8FCE' },
          { id: 'color', label: 'Color Palette', icon: 'üé®', color: '#F7DC6F' },
          { id: 'style', label: 'Style', icon: 'üñºÔ∏è', color: '#85C1E9' },
          { id: 'mood', label: 'Mood', icon: '‚ú®', color: '#F1948A' },
          { id: 'quality', label: 'Quality', icon: 'üíé', color: '#D7BDE2' }
        ]
      },
      {
        id: 'cinematic',
        name: 'Cinematic',
        icon: 'üé¨',
        description: 'Film stills, movie scenes',
        categories: [
          { id: 'instruction', label: 'Instruction', icon: 'üìù', color: '#74B9FF' },
          { id: 'scene', label: 'Scene Description', icon: 'üé¨', color: '#FF6B6B' },
          { id: 'character', label: 'Character', icon: 'üé≠', color: '#4ECDC4' },
          { id: 'action', label: 'Action', icon: '‚ö°', color: '#FFA94D' },
          { id: 'setting', label: 'Setting', icon: 'üèõÔ∏è', color: '#45B7D1' },
          { id: 'cinematography', label: 'Cinematography', icon: 'üì∑', color: '#BB8FCE' },
          { id: 'lighting', label: 'Lighting', icon: 'üí°', color: '#F7DC6F' },
          { id: 'colorgrade', label: 'Color Grade', icon: 'üé®', color: '#85C1E9' },
          { id: 'mood', label: 'Mood / Tone', icon: '‚ú®', color: '#F1948A' },
          { id: 'constraints', label: 'Constraints', icon: 'üîí', color: '#82E0AA' },
          { id: 'quality', label: 'Quality', icon: 'üíé', color: '#D7BDE2' }
        ]
      },
      {
        id: 'concept',
        name: 'Concept Art',
        icon: 'üé®',
        description: 'Illustration, digital art, fantasy',
        categories: [
          { id: 'instruction', label: 'Instruction', icon: 'üìù', color: '#74B9FF' },
          { id: 'subject', label: 'Subject', icon: 'üë§', color: '#FF6B6B' },
          { id: 'setting', label: 'Setting / World', icon: 'üåç', color: '#45B7D1' },
          { id: 'details', label: 'Details', icon: '‚ú®', color: '#FFA94D' },
          { id: 'artstyle', label: 'Art Style', icon: 'üñåÔ∏è', color: '#BB8FCE' },
          { id: 'medium', label: 'Medium', icon: 'üé®', color: '#4ECDC4' },
          { id: 'color', label: 'Color Palette', icon: 'üåà', color: '#F7DC6F' },
          { id: 'mood', label: 'Mood', icon: 'üí´', color: '#F1948A' },
          { id: 'reference', label: 'Artist Reference', icon: 'üë®‚Äçüé®¬çüé®', color: '#85C1E9' },
          { id: 'quality', label: 'Quality', icon: 'üíé', color: '#D7BDE2' }
        ]
      },
      {
        id: 'minimal',
        name: 'Minimal',
        icon: '‚ö°',
        description: 'Quick, simple prompt structure',
        categories: [
          { id: 'instruction', label: 'Instruction', icon: 'üìù', color: '#74B9FF' },
          { id: 'subject', label: 'Subject', icon: 'üë§', color: '#FF6B6B' },
          { id: 'style', label: 'Style', icon: 'üé®', color: '#4ECDC4' },
          { id: 'quality', label: 'Quality', icon: 'üíé', color: '#D7BDE2' }
        ]
      },
      {
        id: 'textrender',
        name: 'Text Render',
        icon: 'üì§',
        description: 'Typography, text-based images',
        categories: [
          { id: 'instruction', label: 'Instruction', icon: 'üìù', color: '#74B9FF' },
          { id: 'textcontent', label: 'Text Content', icon: 'üí¨', color: '#FF6B6B' },
          { id: 'fontstyle', label: 'Font Style', icon: 'üì§', color: '#4ECDC4' },
          { id: 'placement', label: 'Placement', icon: 'üìê', color: '#FFA94D' },
          { id: 'background', label: 'Background', icon: 'üñºÔ∏è', color: '#45B7D1' },
          { id: 'effects', label: 'Effects', icon: '‚ú®', color: '#BB8FCE' },
          { id: 'color', label: 'Color Palette', icon: 'üé®', color: '#F7DC6F' },
          { id: 'style', label: 'Style', icon: 'üñåÔ∏è', color: '#85C1E9' },
          { id: 'quality', label: 'Quality', icon: 'üíé', color: '#D7BDE2' }
        ]
      },
      {
        id: 'duosubject',
        name: 'Duo Subject',
        icon: 'üë•',
        description: 'Two subjects interacting',
        categories: [
          { id: 'instruction', label: 'Instruction', icon: 'üìù', color: '#74B9FF' },
          { id: 'subject1', label: 'Subject 1', icon: 'üë§', color: '#FF6B6B' },
          { id: 'subject2', label: 'Subject 2', icon: 'üë§', color: '#FF8E72' },
          { id: 'interaction', label: 'Interaction', icon: 'ü§ù', color: '#4ECDC4' },
          { id: 'environment', label: 'Environment', icon: 'üåç', color: '#45B7D1' },
          { id: 'camera', label: 'Camera', icon: 'üì∑', color: '#BB8FCE' },
          { id: 'lighting', label: 'Lighting', icon: 'üí°', color: '#F7DC6F' },
          { id: 'color', label: 'Color Palette', icon: 'üé®', color: '#FFA94D' },
          { id: 'style', label: 'Style', icon: 'üñºÔ∏è', color: '#85C1E9' },
          { id: 'mood', label: 'Mood', icon: '‚ú®', color: '#F1948A' },
          { id: 'quality', label: 'Quality', icon: 'üíé', color: '#D7BDE2' }
        ]
      }
    ];
    
    // Curated color palette - easy on eyes, distinct, works on dark backgrounds
    const COLOR_PALETTE = [
      // Row 1: Warm tones
      '#FF6B6B', // Coral red
      '#FF8E72', // Peach
      '#FFA94D', // Orange
      '#FFD43B', // Golden yellow
      '#F7DC6F', // Soft yellow
      '#C9E4CA', // Sage
      
      // Row 2: Cool tones
      '#4ECDC4', // Teal
      '#45B7D1', // Sky blue
      '#74B9FF', // Light blue
      '#A29BFE', // Lavender
      '#BB8FCE', // Purple
      '#F1948A', // Rose
      
      // Row 3: Earth & Muted
      '#82E0AA', // Mint
      '#85C1E9', // Powder blue
      '#D7BDE2', // Lilac
      '#E8DAEF', // Pale lavender
      '#FADBD8', // Blush
      '#F5CBA7', // Tan
      
      // Row 4: Deep & Rich
      '#5DADE2', // Ocean blue
      '#48C9B0', // Seafoam
      '#58D68D', // Green
      '#F4D03F', // Mustard
      '#EB984E', // Burnt orange
      '#EC7063', // Salmon
      
      // Row 5: Neutrals & Special
      '#ABB2B9', // Cool gray
      '#AEB6BF', // Silver
      '#D5DBDB', // Light gray
      '#FDEBD0', // Cream
      '#E8F8F5', // Mint cream
      '#EBF5FB', // Ice blue
    ];
    
    // ============ STATE ============
    let categories = [];
    let library = {};
    let slots = {};
    let references = [
      { image: null, role: 'Identity' },
      { image: null, role: 'Composition' },
      { image: null, role: 'Lighting' }
    ];
    let templates = [];
    let currentTemplateName = '';
    let expandedCategory = null;
    let editMode = false;
    let activeImageSlot = null;
    let activeColorPicker = null; // Which folder's color picker is open
    
    // Blueprint state
    let customBlueprints = []; // All blueprints (including migrated defaults)
    let currentBlueprintId = 'portrait'; // Currently active blueprint
    let deletedItems = { folders: [], blueprints: [] }; // Trash - items expire after 7 days
    const TRASH_EXPIRATION_DAYS = 7;
    let blueprintEditMode = false; // Edit mode for blueprint management
    
    // Drag state
    let isDragging = false;
    let dragData = null;
    let dragGhost = null;
    let pressTimer = null;
    let pressStartChip = null;
    let touchStartPos = { x: 0, y: 0 };
    
    // New folder state
    let selectedEmoji = 'üìù';
    
    // ============ HELPER FUNCTIONS ============
    function hexToRgba(hex, alpha) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }
    
    // ============ INITIALIZATION ============
    function initializeData() {
      const saved = loadFromStorage();
      
      if (saved && saved.categories && saved.categories.length > 0) {
        categories = saved.categories;
        library = saved.library || {};
        slots = saved.slots || {};
        templates = saved.templates || [];
        customBlueprints = saved.customBlueprints || [];
        currentBlueprintId = saved.currentBlueprintId || 'portrait';
        deletedItems = saved.deletedItems || { folders: [], blueprints: [] };
        
        // Migration: If blueprints haven't been migrated yet, copy defaults
        if (!saved.blueprintsMigrated) {
          migrateDefaultBlueprints();
        }
      } else {
        // First time - use defaults
        categories = [...DEFAULT_CATEGORIES];
        library = JSON.parse(JSON.stringify(DEFAULT_PHRASES));
        currentBlueprintId = 'portrait';
        deletedItems = { folders: [], blueprints: [] };
        
        // Copy default blueprints to customBlueprints
        customBlueprints = DEFAULT_BLUEPRINTS.map(bp => JSON.parse(JSON.stringify(bp)));
      }
      
      // Initialize slots for all categories
      categories.forEach(cat => {
        if (!slots[cat.id]) slots[cat.id] = [];
      });
      
      // Clean up expired trash items
      cleanupExpiredTrash();
      
      // Save to mark migration complete
      saveToStorage();
    }
    
    function migrateDefaultBlueprints() {
      // Add any default blueprints that don't exist in customBlueprints
      DEFAULT_BLUEPRINTS.forEach(defaultBp => {
        const exists = customBlueprints.some(bp => bp.id === defaultBp.id);
        if (!exists) {
          // Deep copy the default blueprint
          customBlueprints.unshift(JSON.parse(JSON.stringify(defaultBp)));
        }
      });
      console.log('Migrated default blueprints to customBlueprints');
    }
    
    function loadFromStorage() {
      try {
        const saved = localStorage.getItem('promptBlocksV2');
        if (saved) {
          return JSON.parse(saved);
        }
      } catch (e) {
        console.log('Could not load from storage');
      }
      return null;
    }
    
    function saveToStorage() {
      try {
        const data = { 
          categories, library, slots, templates, customBlueprints, 
          currentBlueprintId, deletedItems, blueprintsMigrated: true 
        };
        localStorage.setItem('promptBlocksV2', JSON.stringify(data));
      } catch (e) {
        console.log('Could not save to storage');
      }
    }
    
    // ============ RECENTLY DELETED / TRASH ============
    function cleanupExpiredTrash() {
      const now = Date.now();
      let cleaned = false;
      
      // Clean expired folders
      const originalFolderCount = deletedItems.folders.length;
      deletedItems.folders = deletedItems.folders.filter(item => item.expiresAt > now);
      if (deletedItems.folders.length < originalFolderCount) cleaned = true;
      
      // Clean expired blueprints
      const originalBlueprintCount = deletedItems.blueprints.length;
      deletedItems.blueprints = deletedItems.blueprints.filter(item => item.expiresAt > now);
      if (deletedItems.blueprints.length < originalBlueprintCount) cleaned = true;
      
      if (cleaned) {
        saveToStorage();
        console.log('Cleaned up expired trash items');
      }
    }
    
    function moveToTrash(type, item, additionalData = {}) {
      const now = Date.now();
      const expiresAt = now + (TRASH_EXPIRATION_DAYS * 24 * 60 * 60 * 1000);
      
      const trashItem = {
        item: JSON.parse(JSON.stringify(item)), // Deep copy
        ...additionalData,
        deletedAt: now,
        expiresAt: expiresAt
      };
      
      if (type === 'folder') {
        deletedItems.folders.push(trashItem);
      } else if (type === 'blueprint') {
        deletedItems.blueprints.push(trashItem);
      }
      
      saveToStorage();
    }
    
    function restoreFromTrash(type, index) {
      if (type === 'folder' && deletedItems.folders[index]) {
        const trashItem = deletedItems.folders[index];
        const folder = trashItem.item;
        const folderLibrary = trashItem.library || [];
        
        // Check if folder ID already exists
        if (categories.find(c => c.id === folder.id)) {
          folder.id = folder.id + '_restored_' + Date.now();
        }
        
        // Restore folder and its phrases
        categories.push(folder);
        library[folder.id] = folderLibrary;
        slots[folder.id] = [];
        
        // Remove from trash
        deletedItems.folders.splice(index, 1);
        
        saveToStorage();
        renderLibrary();
        renderSlots();
        renderTrashSection();
        updateTrashBadge();
        showToast(`üìÇ Restored "${folder.label}"`);
        
      } else if (type === 'blueprint' && deletedItems.blueprints[index]) {
        const trashItem = deletedItems.blueprints[index];
        const blueprint = trashItem.item;
        
        // Check if blueprint ID already exists
        if (customBlueprints.find(b => b.id === blueprint.id)) {
          blueprint.id = blueprint.id + '_restored_' + Date.now();
        }
        
        // Restore blueprint
        customBlueprints.push(blueprint);
        
        // Remove from trash
        deletedItems.blueprints.splice(index, 1);
        
        saveToStorage();
        renderBlueprintGrid();
        renderTrashSection();
        updateTrashBadge();
        showToast(`üìã Restored "${blueprint.name}"`);
      }
    }
    
    function permanentlyDeleteFromTrash(type, index) {
      if (type === 'folder' && deletedItems.folders[index]) {
        const folder = deletedItems.folders[index].item;
        deletedItems.folders.splice(index, 1);
        saveToStorage();
        renderTrashSection();
        updateTrashBadge();
        showToast(`üóëÔ∏è Permanently deleted "${folder.label}"`);
        
      } else if (type === 'blueprint' && deletedItems.blueprints[index]) {
        const blueprint = deletedItems.blueprints[index].item;
        deletedItems.blueprints.splice(index, 1);
        saveToStorage();
        renderTrashSection();
        updateTrashBadge();
        showToast(`üóëÔ∏è Permanently deleted "${blueprint.name}"`);
      }
    }
    
    function emptyTrash() {
      if (!confirm('Permanently delete all items in trash? This cannot be undone.')) return;
      
      deletedItems = { folders: [], blueprints: [] };
      saveToStorage();
      renderTrashSection();
      updateTrashBadge();
      showToast('üóëÔ∏è Trash emptied');
    }
    
    function getTimeRemaining(expiresAt) {
      const now = Date.now();
      const remaining = expiresAt - now;
      
      if (remaining <= 0) return 'Expired';
      
      const days = Math.floor(remaining / (24 * 60 * 60 * 1000));
      const hours = Math.floor((remaining % (24 * 60 * 60 * 1000)) / (60 * 60 * 1000));
      
      if (days > 0) return `${days}d ${hours}h left`;
      if (hours > 0) return `${hours}h left`;
      return 'Less than 1h left';
    }
    
    function renderTrashSection() {
      const container = document.getElementById('trashSection');
      if (!container) return;
      
      const totalItems = deletedItems.folders.length + deletedItems.blueprints.length;
      
      if (totalItems === 0) {
        container.innerHTML = `
          <div class="trash-empty">
            <span class="trash-empty-icon">üóëÔ∏è</span>
            <span class="trash-empty-text">Trash is empty</span>
          </div>
        `;
        return;
      }
      
      let html = `
        <div class="trash-header-row">
          <span class="trash-count">${totalItems} item${totalItems !== 1 ? 's' : ''} in trash</span>
          <button class="trash-empty-btn" onclick="emptyTrash()">Empty Trash</button>
        </div>
        <div class="trash-items">
      `;
      
      // Render deleted blueprints
      deletedItems.blueprints.forEach((item, index) => {
        const bp = item.item;
        const timeLeft = getTimeRemaining(item.expiresAt);
        html += `
          <div class="trash-item">
            <div class="trash-item-info">
              <span class="trash-item-icon">${bp.icon || 'üìã'}</span>
              <div class="trash-item-details">
                <span class="trash-item-name">${bp.name}</span>
                <span class="trash-item-type">Blueprint ¬∑ ${bp.categories?.length || 0} folders</span>
              </div>
            </div>
            <div class="trash-item-meta">
              <span class="trash-item-expires">‚è±Ô∏è ${timeLeft}</span>
              <div class="trash-item-actions">
                <button class="trash-restore-btn" onclick="restoreFromTrash('blueprint', ${index})">‚Ü©Ô∏è Restore</button>
                <button class="trash-delete-btn" onclick="permanentlyDeleteFromTrash('blueprint', ${index})">‚úï</button>
              </div>
            </div>
          </div>
        `;
      });
      
      // Render deleted folders
      deletedItems.folders.forEach((item, index) => {
        const folder = item.item;
        const phraseCount = item.library?.length || 0;
        const timeLeft = getTimeRemaining(item.expiresAt);
        html += `
          <div class="trash-item">
            <div class="trash-item-info">
              <span class="trash-item-icon">${folder.icon || 'üìÅ'}</span>
              <div class="trash-item-details">
                <span class="trash-item-name">${folder.label}</span>
                <span class="trash-item-type">Folder ¬∑ ${phraseCount} phrases</span>
              </div>
            </div>
            <div class="trash-item-meta">
              <span class="trash-item-expires">‚è±Ô∏è ${timeLeft}</span>
              <div class="trash-item-actions">
                <button class="trash-restore-btn" onclick="restoreFromTrash('folder', ${index})">‚Ü©Ô∏è Restore</button>
                <button class="trash-delete-btn" onclick="permanentlyDeleteFromTrash('folder', ${index})">‚úï</button>
              </div>
            </div>
          </div>
        `;
      });
      
      html += '</div>';
      container.innerHTML = html;
    }
    
    function toggleTrashSection() {
      const btn = document.getElementById('trashToggleBtn');
      const content = document.getElementById('trashContent');
      
      btn.classList.toggle('expanded');
      content.classList.toggle('expanded');
      
      if (content.classList.contains('expanded')) {
        renderTrashSection();
      }
    }
    
    function updateTrashBadge() {
      const btn = document.getElementById('trashToggleBtn');
      if (!btn) return;
      
      const totalItems = deletedItems.folders.length + deletedItems.blueprints.length;
      const label = btn.querySelector('span:first-child');
      
      if (totalItems > 0) {
        label.textContent = `üóëÔ∏è Recently Deleted (${totalItems})`;
      } else {
        label.textContent = 'üóëÔ∏è Recently Deleted';
      }
    }
    
    // ============ EDIT MODE ============
    function toggleEditMode() {
      editMode = !editMode;
      const btn = document.getElementById('editBtn');
      const libraryPanel = document.getElementById('libraryPanel');
      
      if (editMode) {
        btn.classList.add('active');
        btn.textContent = '‚úì Done';
        libraryPanel.classList.add('edit-mode');
      } else {
        btn.classList.remove('active');
        btn.textContent = '‚úçÔ∏è Edit';
        libraryPanel.classList.remove('edit-mode');
        saveToStorage();
      }
      
      renderLibrary();
    }
    
    // ============ RENDERING ============
    function renderLibrary() {
      const container = document.getElementById('libraryCategories');
      container.innerHTML = '';
      
      // Add folder button
      const addFolderBtn = document.createElement('button');
      addFolderBtn.className = 'add-folder-btn';
      addFolderBtn.textContent = '+ Add New Folder';
      addFolderBtn.onclick = openFolderModal;
      container.appendChild(addFolderBtn);
      
      categories.forEach((category, catIndex) => {
        const phrases = library[category.id] || [];
        const isExpanded = expandedCategory === category.id;
        
        const categoryDiv = document.createElement('div');
        categoryDiv.className = 'library-category';
        categoryDiv.dataset.categoryId = category.id;
        
        // Create gradient background from the category color
        const bgGradient = `linear-gradient(135deg, ${hexToRgba(category.color, 0.25)} 0%, ${hexToRgba(category.color, 0.15)} 100%)`;
        
        // Check if this is a duplicatable folder (not the original defaults can be duplicated too)
        const isCustom = category.id.startsWith('custom_') || category.id.startsWith('dup_');
        
        categoryDiv.innerHTML = `
          <div class="category-header ${isExpanded ? 'expanded' : ''}" 
               style="--cat-color: ${category.color}; background: ${bgGradient}; border-color: ${hexToRgba(category.color, 0.3)}"
               data-folder-id="${category.id}"
               onclick="toggleCategory('${category.id}')">
            <div class="category-header-left">
              <span class="folder-icon">${category.icon}</span>
              <span class="folder-label" data-category-id="${category.id}">${category.label}</span>
            </div>
            <div class="category-header-right">
              <button class="folder-action-btn duplicate" 
                      data-category-id="${category.id}"
                      title="Duplicate folder">‚ßâ</button>
              <button class="folder-action-btn delete" 
                      data-category-id="${category.id}"
                      title="Delete folder">√ó</button>
              <button class="folder-color-btn" 
                      style="background: ${category.color}"
                      data-category-id="${category.id}"
                      title="Change color"></button>
              <span class="category-count">${phrases.length}</span>
              <span class="category-arrow">‚ñ∂</span>
            </div>
          </div>
          <div class="category-phrases ${isExpanded ? 'expanded' : ''}" id="phrases-${category.id}" style="--cat-color: ${category.color}">
            ${phrases.map((phrase, idx) => createPhraseChipHTML(phrase, category, idx)).join('')}
            <div class="add-phrase-form" id="addForm-${category.id}">
              <input type="text" placeholder="New phrase..." onkeydown="handleAddKeydown(event, '${category.id}')">
              <button onclick="addPhraseFromForm('${category.id}')">Add</button>
              <button onclick="hideAddForm('${category.id}')">√ó</button>
            </div>
            <button class="add-phrase-btn" id="addBtn-${category.id}" onclick="showAddForm('${category.id}')">+ Add phrase</button>
          </div>
        `;
        container.appendChild(categoryDiv);
      });
      
      // Attach drag listeners to phrases
      document.querySelectorAll('.library-panel .phrase-chip').forEach(chip => {
        attachChipListeners(chip);
      });
      
      // Attach drag listeners to folder headers in edit mode
      document.querySelectorAll('.library-panel .category-header').forEach(header => {
        attachFolderListeners(header);
      });
    }
    
    function renderSlots() {
      const container = document.getElementById('slotsContainer');
      container.innerHTML = '';
      
      categories.forEach(category => {
        const phrases = slots[category.id] || [];
        
        const slotDiv = document.createElement('div');
        slotDiv.className = 'prompt-slot';
        slotDiv.style.setProperty('--slot-color', category.color);
        slotDiv.dataset.category = category.id;
        
        // Create gradient background for slot header
        const slotBgGradient = `linear-gradient(135deg, ${hexToRgba(category.color, 0.3)} 0%, ${hexToRgba(category.color, 0.2)} 100%)`;
        
        slotDiv.innerHTML = `
          <div class="slot-header" style="background: ${slotBgGradient}">
            <span class="slot-icon">${category.icon}</span>
            <span class="slot-label">${category.label}</span>
          </div>
          <div class="slot-content" data-category="${category.id}">
            ${phrases.length === 0 
              ? `<div class="slot-placeholder">Drop ${category.label.toLowerCase()} here...</div>`
              : phrases.map((phrase, idx) => createSlotChipHTML(phrase, category, idx)).join('')
            }
          </div>
        `;
        
        container.appendChild(slotDiv);
      });
    }
    
    function renderReferences() {
      const container = document.getElementById('refImagesGrid');
      container.innerHTML = '';
      
      references.forEach((ref, idx) => {
        if (ref.image) {
          // Filled slot - use div
          const slotDiv = document.createElement('div');
          slotDiv.className = 'ref-image-slot filled';
          slotDiv.innerHTML = `
            <img src="${ref.image}" alt="Reference" class="ref-image-preview">
            <select class="ref-role-select" onchange="changeRefRole(${idx}, this.value)">
              ${REFERENCE_ROLES.map(role => 
                `<option value="${role}" ${ref.role === role ? 'selected' : ''}>${role}</option>`
              ).join('')}
            </select>
            <button class="ref-remove" onclick="removeRefImage(${idx})">√ó</button>
          `;
          container.appendChild(slotDiv);
        } else {
          // Empty slot - use label for native file input trigger on iOS
          const slotLabel = document.createElement('label');
          slotLabel.className = 'ref-image-slot empty';
          slotLabel.setAttribute('for', 'imageInput');
          slotLabel.innerHTML = `
            <div class="ref-add-icon">+</div>
            <div class="ref-add-text">Add Ref</div>
          `;
          // Use both click and touch for better compatibility
          slotLabel.addEventListener('mousedown', () => {
            activeImageSlot = idx;
          });
          slotLabel.addEventListener('touchstart', () => {
            activeImageSlot = idx;
          }, { passive: true });
          container.appendChild(slotLabel);
        }
      });
      
      // Add more button if less than 6
      if (references.length < 6) {
        const addSlot = document.createElement('div');
        addSlot.className = 'ref-image-slot empty add-more';
        addSlot.innerHTML = `
          <div class="ref-add-icon">+</div>
          <div class="ref-add-text">More</div>
        `;
        addSlot.addEventListener('click', () => {
          references.push({ image: null, role: 'Style' });
          renderReferences();
        });
        addSlot.addEventListener('touchend', (e) => {
          e.preventDefault();
          references.push({ image: null, role: 'Style' });
          renderReferences();
        }, { passive: false });
        container.appendChild(addSlot);
      }
    }
    
    function renderPreview() {
      const preview = document.getElementById('previewContent');
      const copyBtn = document.getElementById('copyBtn');
      
      let htmlParts = [];
      let textParts = []; // Plain text for copying
      
      // Reference images section
      const activeRefs = references.filter(r => r.image);
      if (activeRefs.length > 0) {
        htmlParts.push('<span class="preview-ref">[Reference Images Attached]</span>');
        textParts.push('[Reference Images Attached]');
        activeRefs.forEach((ref, i) => {
          htmlParts.push(`<span class="preview-ref">Image ${i + 1}: Use for ${ref.role.toUpperCase()}</span>`);
          textParts.push(`Image ${i + 1}: Use for ${ref.role.toUpperCase()}`);
        });
        htmlParts.push('');
        textParts.push('');
      }
      
      // Build prompt based on category order
      categories.forEach(category => {
        const phrases = slots[category.id] || [];
        if (phrases.length > 0) {
          const color = category.color;
          const coloredPhrases = phrases.map(p => 
            `<span class="preview-phrase" style="color: ${color}">${escapeHTML(p)}</span>`
          );
          
          // Determine base category type (handles duplicates like "Subject (2)")
          const baseId = category.id.replace(/^dup_\d+$/, '').replace(/_copy.*/, '');
          const baseLabelLower = category.label.toLowerCase().replace(/\s*\(\d+\)$/, '');
          
          // Categories that show constraints (separate lines)
          if (baseLabelLower.includes('constraint')) {
            htmlParts.push(`\n${coloredPhrases.join('\n')}`);
            textParts.push(`\n${phrases.join('\n')}`);
          }
          // Categories with labels (technical settings)
          else if (baseLabelLower.includes('lighting') || baseLabelLower.includes('camera') || 
                   baseLabelLower.includes('style') || baseLabelLower.includes('mood') || 
                   baseLabelLower.includes('quality') || baseLabelLower.includes('color')) {
            htmlParts.push(`<span class="preview-label">${category.label}:</span> ${coloredPhrases.join('<span class="preview-sep">; </span>')}`);
            textParts.push(`${category.label}: ${phrases.join('; ')}`);
          }
          // Instruction and descriptive categories (inline, no label)
          else {
            htmlParts.push(coloredPhrases.join('<span class="preview-sep">, </span>'));
            textParts.push(phrases.join(', '));
          }
        }
      });
      
      const isEmpty = !categories.some(cat => slots[cat.id]?.length > 0) && activeRefs.length === 0;
      
      if (isEmpty) {
        preview.innerHTML = '<span class="empty">Start adding phrases to build your prompt...</span>';
      } else {
        preview.innerHTML = htmlParts.join('\n');
      }
      
      // Store plain text for copying
      preview.dataset.plainText = textParts.join('\n').trim();
      
      preview.className = `preview-content ${isEmpty ? 'empty' : ''}`;
      copyBtn.disabled = isEmpty;
    }
    
    function renderTemplateSelect() {
      const select = document.getElementById('templateSelect');
      select.innerHTML = '<option value="">üìÇ Load...</option>';
      templates.forEach(t => {
        const option = document.createElement('option');
        option.value = t.name;
        option.textContent = t.name;
        select.appendChild(option);
      });
    }
    
    function createPhraseChipHTML(phrase, category, index) {
      return `
        <div class="phrase-chip" 
             style="--chip-color: ${category.color}"
             data-phrase="${escapeHTML(phrase)}"
             data-category="${category.id}"
             data-index="${index}">
          <button class="phrase-delete" onclick="event.stopPropagation(); deletePhrase('${category.id}', ${index})">√ó</button>
          <span class="chip-icon">${category.icon}</span>
          <span class="chip-text">${escapeHTML(phrase)}</span>
        </div>
      `;
    }
    
    function createSlotChipHTML(phrase, category, index) {
      return `
        <div class="phrase-chip in-slot" 
             style="--chip-color: ${category.color}"
             data-phrase="${escapeHTML(phrase)}"
             data-category="${category.id}"
             data-index="${index}">
          <span class="chip-icon">${category.icon}</span>
          <span class="chip-text">${escapeHTML(phrase)}</span>
          <button class="chip-remove" onclick="event.stopPropagation(); removeFromSlot('${category.id}', ${index})">√ó</button>
        </div>
      `;
    }
    
    function escapeHTML(str) {
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
    }
    
    // ============ FOLDER MANAGEMENT ============
    function openFolderModal() {
      document.getElementById('folderModal').classList.add('active');
      document.getElementById('newFolderName').focus();
      selectedEmoji = 'üìù';
      updateEmojiSelection();
    }
    
    function closeFolderModal() {
      document.getElementById('folderModal').classList.remove('active');
      document.getElementById('newFolderName').value = '';
    }
    
    function updateEmojiSelection() {
      document.querySelectorAll('.emoji-option').forEach(opt => {
        opt.classList.toggle('selected', opt.dataset.emoji === selectedEmoji);
      });
    }
    
    function createNewFolder() {
      const name = document.getElementById('newFolderName').value.trim();
      if (!name) {
        showToast('Please enter a folder name');
        return;
      }
      
      const id = 'custom_' + Date.now();
      const color = COLOR_PALETTE[Math.floor(Math.random() * COLOR_PALETTE.length)];
      
      categories.push({
        id: id,
        label: name,
        icon: selectedEmoji,
        color: color
      });
      
      library[id] = [];
      slots[id] = [];
      
      saveToStorage();
      closeFolderModal();
      renderLibrary();
      renderSlots();
      showToast(`Folder "${name}" created!`);
    }
    
    // ============ COLOR PICKER (Global Modal) ============
    function openColorPicker(categoryId) {
      activeColorPicker = categoryId;
      const category = categories.find(c => c.id === categoryId);
      
      // Populate the color grid
      const grid = document.getElementById('colorPickerGrid');
      grid.innerHTML = COLOR_PALETTE.map(color => `
        <div class="color-option ${category && category.color === color ? 'selected' : ''}" 
             style="background: ${color}"
             data-color="${color}"></div>
      `).join('');
      
      // Show modal
      document.getElementById('colorPickerOverlay').classList.add('active');
      document.getElementById('colorPickerModal').classList.add('active');
    }
    
    function closeColorPicker() {
      activeColorPicker = null;
      document.getElementById('colorPickerOverlay').classList.remove('active');
      document.getElementById('colorPickerModal').classList.remove('active');
    }
    
    function setFolderColor(categoryId, color) {
      const category = categories.find(c => c.id === categoryId);
      if (category) {
        category.color = color;
        saveToStorage();
        
        // Update the folder header background
        const header = document.querySelector(`[data-folder-id="${categoryId}"]`);
        if (header) {
          const bgGradient = `linear-gradient(135deg, ${hexToRgba(color, 0.25)} 0%, ${hexToRgba(color, 0.15)} 100%)`;
          header.style.background = bgGradient;
          header.style.borderColor = hexToRgba(color, 0.3);
          header.style.setProperty('--cat-color', color);
          
          // Update color button
          const colorBtn = header.querySelector('.folder-color-btn');
          if (colorBtn) colorBtn.style.background = color;
        }
        
        // Update selected state in color picker grid
        document.querySelectorAll('#colorPickerGrid .color-option').forEach(opt => {
          opt.classList.toggle('selected', opt.dataset.color === color);
        });
        
        // Update the slot in build panel and preview text colors
        renderSlots();
        renderPreview();
      }
    }
    
    function closeAllColorPickers() {
      closeColorPicker();
    }
    
    // ============ FOLDER DUPLICATION ============
    function duplicateFolder(categoryId) {
      const sourceCategory = categories.find(c => c.id === categoryId);
      if (!sourceCategory) return;
      
      // Create new unique ID
      const newId = 'dup_' + Date.now();
      
      // Find a good label - add (2), (3), etc.
      let baseLabel = sourceCategory.label.replace(/\s*\(\d+\)$/, ''); // Remove existing number
      let counter = 2;
      let newLabel = `${baseLabel} (${counter})`;
      
      // Check for existing duplicates
      while (categories.some(c => c.label === newLabel)) {
        counter++;
        newLabel = `${baseLabel} (${counter})`;
      }
      
      // Create new category with same properties but different ID and label
      const newCategory = {
        id: newId,
        label: newLabel,
        icon: sourceCategory.icon,
        color: sourceCategory.color
      };
      
      // Find position right after source category
      const sourceIndex = categories.findIndex(c => c.id === categoryId);
      categories.splice(sourceIndex + 1, 0, newCategory);
      
      // Copy the phrases (deep copy)
      library[newId] = [...(library[categoryId] || [])];
      
      // Initialize empty slots for new category
      slots[newId] = [];
      
      saveToStorage();
      renderLibrary();
      renderSlots();
      showToast(`Folder duplicated as "${newLabel}"`);
      
      // Optionally expand the new folder
      expandedCategory = newId;
      renderLibrary();
    }
    
    function renameFolder(categoryId) {
      const category = categories.find(c => c.id === categoryId);
      if (!category) return;
      
      const newName = prompt('Rename folder:', category.label);
      if (newName && newName.trim() && newName.trim() !== category.label) {
        category.label = newName.trim();
        saveToStorage();
        renderLibrary();
        renderSlots();
        renderPreview();
        showToast(`Folder renamed to "${newName.trim()}"`);
      }
    }
    
    function deleteFolder(categoryId) {
      const category = categories.find(c => c.id === categoryId);
      if (!category) return;
      
      if (!confirm(`Move folder "${category.label}" to trash?`)) return;
      
      // Move to trash with library contents
      moveToTrash('folder', category, { library: library[categoryId] || [] });
      
      categories = categories.filter(c => c.id !== categoryId);
      delete library[categoryId];
      delete slots[categoryId];
      
      saveToStorage();
      renderLibrary();
      renderSlots();
      renderPreview();
      showToast(`üóëÔ∏è Moved to trash (7 days to restore)`);
    }
    
    // ============ BLUEPRINTS ============
    function getAllBlueprints() {
      // All blueprints now live in customBlueprints (including migrated defaults)
      return customBlueprints;
    }
    
    function openBlueprintModal() {
      renderBlueprintGrid();
      updateTrashBadge();
      document.getElementById('blueprintOverlay').classList.add('active');
      document.getElementById('blueprintModal').classList.add('active');
    }
    
    function closeBlueprintModal() {
      document.getElementById('blueprintOverlay').classList.remove('active');
      document.getElementById('blueprintModal').classList.remove('active');
      
      // Reset edit mode when closing
      if (blueprintEditMode) {
        blueprintEditMode = false;
        const btn = document.getElementById('blueprintEditBtn');
        if (btn) {
          btn.classList.remove('active');
          btn.textContent = '‚úçÔ∏è Edit';
        }
      }
    }
    
    function renderBlueprintGrid() {
      const grid = document.getElementById('blueprintGrid');
      const allBlueprints = getAllBlueprints();
      
      grid.innerHTML = allBlueprints.map(bp => {
        const isActive = bp.id === currentBlueprintId;
        const isDefault = DEFAULT_BLUEPRINTS.some(d => d.id === bp.id);
        const hasSavedState = bp.savedSlots && bp.savedLibrary;
        
        // Truncate description if too long (show full on active)
        const maxDescLength = 60;
        const description = bp.description || '';
        const truncatedDesc = description.length > maxDescLength && !isActive
          ? description.substring(0, maxDescLength) + '...'
          : description;
        
        return `
          <div class="blueprint-card ${isActive ? 'active' : ''} ${blueprintEditMode ? 'edit-mode' : ''}" data-blueprint-id="${bp.id}">
            <div class="blueprint-card-header">
              <span class="blueprint-icon">${bp.icon}</span>
              <span class="blueprint-name">${bp.name}</span>
              ${isDefault ? '<span class="blueprint-default-badge">Default</span>' : ''}
              ${hasSavedState ? '<span class="blueprint-state-badge">üíæ</span>' : ''}
            </div>
            <div class="blueprint-description ${isActive ? 'expanded' : ''}">${truncatedDesc}</div>
            <div class="blueprint-meta">${bp.categories.length} folders</div>
            ${isActive ? '<div class="blueprint-active-badge">Active</div>' : ''}
            <div class="blueprint-card-actions">
              <button class="blueprint-export-btn" data-blueprint-id="${bp.id}">üì§ Export</button>
              <button class="blueprint-duplicate-btn" data-blueprint-id="${bp.id}">üìã Duplicate</button>
              ${blueprintEditMode ? `<button class="blueprint-delete-btn" data-blueprint-id="${bp.id}">üóëÔ∏è Delete</button>` : ''}
            </div>
          </div>
        `;
      }).join('');
    }
    
    function toggleBlueprintEditMode() {
      blueprintEditMode = !blueprintEditMode;
      const btn = document.getElementById('blueprintEditBtn');
      
      if (blueprintEditMode) {
        btn.classList.add('active');
        btn.textContent = '‚úì Done';
      } else {
        btn.classList.remove('active');
        btn.textContent = '‚úçÔ∏è Edit';
      }
      
      renderBlueprintGrid();
    }
    
    function duplicateBlueprint(blueprintId) {
      const allBlueprints = getAllBlueprints();
      const original = allBlueprints.find(bp => bp.id === blueprintId);
      if (!original) return;
      
      // Prompt for new name
      const newName = prompt(`Name for duplicated blueprint:`, `${original.name} (Copy)`);
      if (!newName || !newName.trim()) return;
      
      // Create deep copy with new ID and name
      const duplicate = JSON.parse(JSON.stringify(original));
      duplicate.id = 'blueprint_' + Date.now();
      duplicate.name = newName.trim();
      
      // Add to blueprints
      customBlueprints.push(duplicate);
      saveToStorage();
      renderBlueprintGrid();
      showToast(`üìã Duplicated "${original.name}"`);
    }
    
    function loadBlueprint(blueprintId) {
      const allBlueprints = getAllBlueprints();
      const blueprint = allBlueprints.find(bp => bp.id === blueprintId);
      if (!blueprint) return;
      
      // Check if there's current work
      const hasWork = categories.some(cat => slots[cat.id]?.length > 0);
      if (hasWork) {
        if (!confirm(`Loading "${blueprint.name}" will clear your current prompt. Continue?`)) {
          return;
        }
      }
      
      // Check if blueprint has saved state
      const hasSavedState = blueprint.savedSlots && blueprint.savedLibrary;
      let loadState = false;
      
      if (hasSavedState) {
        loadState = confirm(`This blueprint has saved prompt state.\n\nLoad with saved phrases and slots?`);
      }
      
      // Load the blueprint's category structure
      categories = blueprint.categories.map(cat => ({...cat}));
      currentBlueprintId = blueprintId;
      
      if (loadState && hasSavedState) {
        // Restore saved library and slots
        library = JSON.parse(JSON.stringify(blueprint.savedLibrary));
        slots = JSON.parse(JSON.stringify(blueprint.savedSlots));
        
        // Ensure all categories have slot arrays
        categories.forEach(cat => {
          if (!slots[cat.id]) slots[cat.id] = [];
        });
      } else {
        // Default behavior: use existing library or defaults
        categories.forEach(cat => {
          if (!library[cat.id]) {
            // Try to get default phrases for this category
            library[cat.id] = DEFAULT_PHRASES[cat.id] ? [...DEFAULT_PHRASES[cat.id]] : [];
          }
        });
        
        // Clear slots
        slots = {};
        categories.forEach(cat => {
          slots[cat.id] = [];
        });
      }
      
      // Clear expanded state
      expandedCategory = null;
      
      saveToStorage();
      renderLibrary();
      renderSlots();
      renderPreview();
      renderBlueprintGrid();
      updateBlueprintButton();
      closeBlueprintModal();
      
      showToast(`Loaded "${blueprint.name}"${loadState ? ' with saved state' : ''}`);
    }
    
    function saveCurrentAsBlueprint() {
      const name = prompt('Name your blueprint:');
      if (!name || !name.trim()) return;
      
      const id = 'custom_' + Date.now();
      const icon = prompt('Choose an icon (emoji):', 'üìã') || 'üìã';
      const description = prompt('Short description:', 'Custom blueprint') || 'Custom blueprint';
      
      // Ask if user wants to save current prompt state
      const saveState = confirm('Save current slot contents and phrases?\n\nYes = Include your current prompt setup\nNo = Save structure only');
      
      const newBlueprint = {
        id: id,
        name: name.trim(),
        icon: icon,
        description: description,
        categories: categories.map(cat => ({...cat}))
      };
      
      // Optionally save prompt state
      if (saveState) {
        // Deep copy slots (current phrase selections)
        newBlueprint.savedSlots = JSON.parse(JSON.stringify(slots));
        // Deep copy library (all phrases in each folder)
        newBlueprint.savedLibrary = JSON.parse(JSON.stringify(library));
        // Save the generated prompt text
        const preview = document.getElementById('previewContent');
        newBlueprint.savedPrompt = preview.dataset.plainText || preview.textContent;
      }
      
      customBlueprints.push(newBlueprint);
      currentBlueprintId = id;
      
      saveToStorage();
      renderBlueprintGrid();
      updateBlueprintButton();
      showToast(`Blueprint "${name.trim()}" saved!${saveState ? ' (with prompt state)' : ''}`);
    }
    
    function deleteBlueprint(blueprintId) {
      const blueprint = customBlueprints.find(bp => bp.id === blueprintId);
      if (!blueprint) return;
      
      // Prevent deleting the last blueprint
      if (customBlueprints.length <= 1) {
        showToast('‚ö†Ô∏è Cannot delete the last blueprint');
        return;
      }
      
      if (!confirm(`Move blueprint "${blueprint.name}" to trash?`)) return;
      
      // Move to trash instead of permanent delete
      moveToTrash('blueprint', blueprint);
      
      customBlueprints = customBlueprints.filter(bp => bp.id !== blueprintId);
      
      // If we deleted the active blueprint, switch to first available
      if (currentBlueprintId === blueprintId) {
        currentBlueprintId = customBlueprints[0]?.id || 'portrait';
      }
      
      saveToStorage();
      renderBlueprintGrid();
      updateBlueprintButton();
      
      // Update trash section if it's open
      renderTrashSection();
      updateTrashBadge();
      
      showToast('üóëÔ∏è Moved to trash (7 days to restore)');
    }
    
    function updateBlueprintButton() {
      const btn = document.getElementById('blueprintBtn');
      const allBlueprints = getAllBlueprints();
      const current = allBlueprints.find(bp => bp.id === currentBlueprintId);
      if (current && btn) {
        btn.innerHTML = `${current.icon} ${current.name}`;
      }
    }
    
    // ============ ADD FOLDER FROM BLUEPRINT ============
    function openAddFolderModal() {
      renderAddFolderGrid();
      document.getElementById('addFolderOverlay').classList.add('active');
      document.getElementById('addFolderModal').classList.add('active');
    }
    
    function closeAddFolderModal() {
      document.getElementById('addFolderOverlay').classList.remove('active');
      document.getElementById('addFolderModal').classList.remove('active');
    }
    
    function renderAddFolderGrid() {
      const grid = document.getElementById('addFolderGrid');
      const allBlueprints = getAllBlueprints();
      const currentCategoryIds = categories.map(c => c.id);
      
      // Collect all unique folders from all blueprints
      const foldersByBlueprint = {};
      
      allBlueprints.forEach(bp => {
        foldersByBlueprint[bp.id] = {
          name: bp.name,
          icon: bp.icon,
          folders: bp.categories.filter(cat => {
            // Show folders that aren't already in current structure
            // (by checking both id and label to catch duplicates)
            return !currentCategoryIds.includes(cat.id);
          })
        };
      });
      
      let html = '';
      
      Object.keys(foldersByBlueprint).forEach(bpId => {
        const bp = foldersByBlueprint[bpId];
        if (bp.folders.length === 0) return;
        
        html += `
          <div class="add-folder-blueprint-section">
            <div class="add-folder-blueprint-title">${bp.icon} ${bp.name}</div>
            <div class="add-folder-list">
              ${bp.folders.map(folder => `
                <div class="add-folder-item" 
                     data-folder-id="${folder.id}"
                     data-folder-label="${escapeHTML(folder.label)}"
                     data-folder-icon="${folder.icon}"
                     data-folder-color="${folder.color}">
                  <span class="add-folder-item-icon">${folder.icon}</span>
                  <span class="add-folder-item-label">${folder.label}</span>
                  ${DEFAULT_PHRASES[folder.id] ? `<span class="add-folder-item-badge">${DEFAULT_PHRASES[folder.id].length} phrases</span>` : ''}
                </div>
              `).join('')}
            </div>
          </div>
        `;
      });
      
      if (!html) {
        html = '<div style="color: #666; text-align: center; padding: 40px;">All available folders are already in your current structure.</div>';
      }
      
      grid.innerHTML = html;
    }
    
    function addFolderFromBlueprint(folderId, label, icon, color) {
      // Check if folder already exists
      if (categories.some(c => c.id === folderId)) {
        showToast('This folder is already in your structure');
        return;
      }
      
      // Create new category
      const newCategory = {
        id: folderId,
        label: label,
        icon: icon,
        color: color
      };
      
      categories.push(newCategory);
      
      // Add phrases to library if they exist
      if (DEFAULT_PHRASES[folderId] && !library[folderId]) {
        library[folderId] = [...DEFAULT_PHRASES[folderId]];
      }
      if (!library[folderId]) {
        library[folderId] = [];
      }
      
      // Initialize slots
      slots[folderId] = [];
      
      saveToStorage();
      renderLibrary();
      renderSlots();
      renderAddFolderGrid();
      showToast(`Added "${label}" folder`);
    }
    
    // ============ BLUEPRINT EXPORT/IMPORT ============
    function exportBlueprint(blueprintId) {
      const allBlueprints = getAllBlueprints();
      const blueprint = allBlueprints.find(bp => bp.id === blueprintId);
      if (!blueprint) return;
      
      // Collect phrases for each category in the blueprint
      const phrases = {};
      blueprint.categories.forEach(cat => {
        // Get phrases from library or DEFAULT_PHRASES
        phrases[cat.id] = library[cat.id] || DEFAULT_PHRASES[cat.id] || [];
      });
      
      // Create export object
      const exportData = {
        version: 2, // Bumped version for state support
        type: 'prompt-blocks-blueprint',
        exportedAt: new Date().toISOString(),
        blueprint: {
          name: blueprint.name,
          icon: blueprint.icon,
          description: blueprint.description,
          categories: blueprint.categories
        },
        phrases: phrases
      };
      
      // Include saved state if it exists
      if (blueprint.savedSlots) {
        exportData.savedSlots = blueprint.savedSlots;
      }
      if (blueprint.savedLibrary) {
        exportData.savedLibrary = blueprint.savedLibrary;
      }
      if (blueprint.savedPrompt) {
        exportData.savedPrompt = blueprint.savedPrompt;
      }
      
      // Create and download file
      const json = JSON.stringify(exportData, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = `blueprint-${blueprint.name.toLowerCase().replace(/\s+/g, '-')}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showToast(`Exported "${blueprint.name}" blueprint`);
    }
    
    function triggerBlueprintImport() {
      document.getElementById('blueprintFileInput').click();
    }
    
    function handleBlueprintImport(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          
          // Validate the file
          if (data.type !== 'prompt-blocks-blueprint' || !data.blueprint) {
            showToast('Invalid blueprint file');
            return;
          }
          
          // Check for duplicate names
          const allBlueprints = getAllBlueprints();
          let newName = data.blueprint.name;
          let counter = 1;
          while (allBlueprints.some(bp => bp.name === newName)) {
            counter++;
            newName = `${data.blueprint.name} (${counter})`;
          }
          
          // Create new custom blueprint
          const newBlueprint = {
            id: 'imported_' + Date.now(),
            name: newName,
            icon: data.blueprint.icon || 'üìã',
            description: data.blueprint.description || 'Imported blueprint',
            categories: data.blueprint.categories.map(cat => ({
              ...cat,
              id: cat.id // Keep original IDs so phrases match
            }))
          };
          
          // Preserve saved state if it exists (v2+ exports)
          if (data.savedSlots) {
            newBlueprint.savedSlots = data.savedSlots;
          }
          if (data.savedLibrary) {
            newBlueprint.savedLibrary = data.savedLibrary;
          }
          if (data.savedPrompt) {
            newBlueprint.savedPrompt = data.savedPrompt;
          }
          
          customBlueprints.push(newBlueprint);
          
          // Merge phrases into library
          if (data.phrases) {
            Object.keys(data.phrases).forEach(catId => {
              if (!library[catId]) {
                library[catId] = [];
              }
              // Add new phrases that don't already exist
              data.phrases[catId].forEach(phrase => {
                if (!library[catId].includes(phrase)) {
                  library[catId].push(phrase);
                }
              });
            });
          }
          
          saveToStorage();
          renderBlueprintGrid();
          
          const hasState = data.savedSlots || data.savedLibrary;
          showToast(`Imported "${newName}"${hasState ? ' (with saved state)' : ''}!`);
          
        } catch (err) {
          console.error('Import error:', err);
          showToast('Error reading blueprint file');
        }
      };
      
      reader.readAsText(file);
      
      // Reset input so same file can be imported again
      event.target.value = '';
    }
    
    // ============ PHRASE MANAGEMENT ============
    function deletePhrase(categoryId, index) {
      if (!library[categoryId]) return;
      library[categoryId].splice(index, 1);
      saveToStorage();
      renderLibrary();
    }
    
    function toggleCategory(categoryId) {
      // Allow toggling even in edit mode, but not while actively dragging
      if (isDragging) return;
      expandedCategory = expandedCategory === categoryId ? null : categoryId;
      renderLibrary();
    }
    
    function removeFromSlot(categoryId, index) {
      if (!slots[categoryId]) return;
      slots[categoryId].splice(index, 1);
      renderSlots();
      renderPreview();
    }
    
    function clearAllSlots() {
      categories.forEach(cat => slots[cat.id] = []);
      currentTemplateName = '';
      document.getElementById('templateCurrent').textContent = 'üìÑ Untitled Prompt';
      renderSlots();
      renderPreview();
    }
    
    function showAddForm(categoryId) {
      document.getElementById(`addForm-${categoryId}`).classList.add('active');
      document.getElementById(`addBtn-${categoryId}`).style.display = 'none';
      document.querySelector(`#addForm-${categoryId} input`).focus();
    }
    
    function hideAddForm(categoryId) {
      document.getElementById(`addForm-${categoryId}`).classList.remove('active');
      document.getElementById(`addBtn-${categoryId}`).style.display = 'block';
      document.querySelector(`#addForm-${categoryId} input`).value = '';
    }
    
    function handleAddKeydown(e, categoryId) {
      if (e.key === 'Enter') addPhraseFromForm(categoryId);
      if (e.key === 'Escape') hideAddForm(categoryId);
    }
    
    function addPhraseFromForm(categoryId) {
      const input = document.querySelector(`#addForm-${categoryId} input`);
      const phrase = input.value.trim();
      if (phrase) {
        if (!library[categoryId]) library[categoryId] = [];
        library[categoryId].push(phrase);
        saveToStorage();
        input.value = '';
        renderLibrary();
        showToast('Phrase added!');
      }
    }
    
    // ============ REFERENCE IMAGES ============
    function addRefImage(index) {
      activeImageSlot = index;
      document.getElementById('imageInput').click();
    }
    
    function handleImageSelect(e) {
      const file = e.target.files[0];
      if (!file || activeImageSlot === null) return;
      
      const reader = new FileReader();
      reader.onload = (event) => {
        references[activeImageSlot].image = event.target.result;
        renderReferences();
        renderPreview();
        showToast('Image added!');
        activeImageSlot = null; // Reset after use
      };
      reader.onerror = () => {
        showToast('Error loading image');
      };
      reader.readAsDataURL(file);
      
      // Reset input so same file can be selected again
      e.target.value = '';
      activeImageSlot = null;
    }
    
    function removeRefImage(index) {
      references[index].image = null;
      renderReferences();
      renderPreview();
    }
    
    function changeRefRole(index, role) {
      references[index].role = role;
      renderPreview();
    }
    
    // ============ LONG-PRESS DRAG SYSTEM ============
    // Supports two modes:
    // - Normal mode: drag phrases to slots
    // - Edit mode: drag to reorder phrases/folders, drag to trash to delete
    
    let editDragType = null; // 'phrase' or 'folder'
    let editDragData = null;
    
    function initDragSystem() {
      dragGhost = document.getElementById('dragGhost');
      
      document.addEventListener('contextmenu', (e) => {
        if (e.target.closest('.phrase-chip') || e.target.closest('.category-header')) {
          e.preventDefault();
        }
      });
      
      document.addEventListener('touchmove', handleDragMove, { passive: false });
      document.addEventListener('touchend', handleDragEnd);
      document.addEventListener('touchcancel', handleDragEnd);
      document.addEventListener('mousemove', handleDragMove);
      document.addEventListener('mouseup', handleDragEnd);
    }
    
    function attachChipListeners(chip) {
      chip.addEventListener('touchstart', handleTouchStart, { passive: false });
      chip.addEventListener('mousedown', handleMouseDown);
    }
    
    function attachFolderListeners(header) {
      header.addEventListener('touchstart', handleFolderTouchStart, { passive: false });
      header.addEventListener('mousedown', handleFolderMouseDown);
    }
    
    // --- Normal mode: phrase to slot ---
    function handleTouchStart(e) {
      const chip = e.target.closest('.phrase-chip');
      if (!chip || chip.classList.contains('in-slot')) return;
      if (e.target.closest('.phrase-delete')) return;
      
      const touch = e.touches[0];
      touchStartPos = { x: touch.clientX, y: touch.clientY };
      pressStartChip = chip;
      
      chip.classList.add('pressing');
      
      pressTimer = setTimeout(() => {
        if (editMode) {
          startEditPhraseDrag(chip, touch.clientX, touch.clientY);
        } else {
          startDrag(chip, touch.clientX, touch.clientY);
        }
      }, 250);
    }
    
    function handleMouseDown(e) {
      const chip = e.target.closest('.phrase-chip');
      if (!chip || chip.classList.contains('in-slot')) return;
      if (e.target.closest('.phrase-delete')) return;
      
      touchStartPos = { x: e.clientX, y: e.clientY };
      pressStartChip = chip;
      
      chip.classList.add('pressing');
      
      pressTimer = setTimeout(() => {
        if (editMode) {
          startEditPhraseDrag(chip, e.clientX, e.clientY);
        } else {
          startDrag(chip, e.clientX, e.clientY);
        }
      }, 250);
    }
    
    // --- Edit mode: folder drag ---
    function handleFolderTouchStart(e) {
      if (!editMode) return;
      
      const header = e.target.closest('.category-header');
      if (!header) return;
      
      e.preventDefault();
      e.stopPropagation();
      
      const touch = e.touches[0];
      touchStartPos = { x: touch.clientX, y: touch.clientY };
      
      pressTimer = setTimeout(() => {
        startFolderDrag(header, touch.clientX, touch.clientY);
      }, 250);
    }
    
    function handleFolderMouseDown(e) {
      if (!editMode) return;
      
      const header = e.target.closest('.category-header');
      if (!header) return;
      
      touchStartPos = { x: e.clientX, y: e.clientY };
      
      pressTimer = setTimeout(() => {
        startFolderDrag(header, e.clientX, e.clientY);
      }, 250);
    }
    
    // --- Start drag functions ---
    function startDrag(chip, x, y) {
      isDragging = true;
      editDragType = null;
      
      const phrase = chip.dataset.phrase;
      const categoryId = chip.dataset.category;
      
      dragData = { phrase, categoryId, sourceChip: chip };
      
      chip.classList.remove('pressing');
      chip.classList.add('picked-up');
      
      dragGhost.textContent = phrase.length > 25 ? phrase.substring(0, 25) + '...' : phrase;
      dragGhost.style.display = 'block';
      dragGhost.style.left = x + 'px';
      dragGhost.style.top = y + 'px';
      
      highlightValidSlots(categoryId);
      
      if (navigator.vibrate) navigator.vibrate(50);
    }
    
    function startEditPhraseDrag(chip, x, y) {
      isDragging = true;
      editDragType = 'phrase';
      
      const phrase = chip.dataset.phrase;
      const categoryId = chip.dataset.category;
      const index = parseInt(chip.dataset.index);
      
      editDragData = { phrase, categoryId, index, sourceChip: chip };
      
      chip.classList.remove('pressing');
      chip.classList.add('picked-up');
      
      dragGhost.textContent = phrase.length > 25 ? phrase.substring(0, 25) + '...' : phrase;
      dragGhost.style.display = 'block';
      dragGhost.style.left = x + 'px';
      dragGhost.style.top = y + 'px';
      
      if (navigator.vibrate) navigator.vibrate(50);
    }
    
    function startFolderDrag(header, x, y) {
      isDragging = true;
      editDragType = 'folder';
      
      const folderId = header.dataset.folderId;
      const category = categories.find(c => c.id === folderId);
      
      editDragData = { folderId, sourceHeader: header };
      
      header.classList.add('dragging-folder');
      
      dragGhost.textContent = `üìù ${category ? category.label : 'Folder'}`;
      dragGhost.style.display = 'block';
      dragGhost.style.left = x + 'px';
      dragGhost.style.top = y + 'px';
      
      if (navigator.vibrate) navigator.vibrate(50);
    }
    
    // --- Handle drag move ---
    function handleDragMove(e) {
      if (pressTimer && !isDragging) {
        const pos = e.touches ? e.touches[0] : e;
        const dx = pos.clientX - touchStartPos.x;
        const dy = pos.clientY - touchStartPos.y;
        if (Math.abs(dx) > 10 || Math.abs(dy) > 10) {
          cancelPress();
        }
        return;
      }
      
      if (!isDragging) return;
      
      e.preventDefault();
      
      const pos = e.touches ? e.touches[0] : e;
      
      dragGhost.style.left = pos.clientX + 'px';
      dragGhost.style.top = pos.clientY + 'px';
      
      if (editMode && editDragType) {
        updateEditDropTarget(pos.clientX, pos.clientY);
      } else {
        updateDropTarget(pos.clientX, pos.clientY);
      }
    }
    
    // --- Handle drag end ---
    function handleDragEnd(e) {
      cancelPress();
      
      if (!isDragging) return;
      
      const pos = e.changedTouches ? e.changedTouches[0] : e;
      
      if (editMode && editDragType) {
        handleEditDragEnd(pos.clientX, pos.clientY);
      } else {
        handleNormalDragEnd(pos.clientX, pos.clientY);
      }
    }
    
    function handleNormalDragEnd(x, y) {
      const dropTarget = getDropTarget(x, y);
      
      if (dropTarget && dropTarget.categoryId === dragData.categoryId) {
        if (!slots[dragData.categoryId]) slots[dragData.categoryId] = [];
        
        if (!slots[dragData.categoryId].includes(dragData.phrase)) {
          slots[dragData.categoryId].push(dragData.phrase);
          
          dragGhost.classList.add('dropping');
          
          setTimeout(() => {
            renderSlots();
            renderPreview();
            cleanupDrag();
          }, 150);
        } else {
          cleanupDrag();
        }
      } else if (dropTarget && dropTarget.categoryId !== dragData.categoryId) {
        dropTarget.element.classList.add('invalid-drop');
        setTimeout(() => {
          dropTarget.element.classList.remove('invalid-drop');
        }, 300);
        cleanupDrag();
      } else {
        cleanupDrag();
      }
    }
    
    function handleEditDragEnd(x, y) {
      // Check if dropped on trash
      const trashTarget = document.getElementById('trashBinTarget');
      const trashRect = trashTarget.getBoundingClientRect();
      
      if (x >= trashRect.left && x <= trashRect.right && y >= trashRect.top && y <= trashRect.bottom) {
        // Dropped on trash!
        if (editDragType === 'phrase') {
          // Delete phrase
          const { categoryId, index } = editDragData;
          library[categoryId].splice(index, 1);
          showToast('Phrase deleted');
        } else if (editDragType === 'folder') {
          // Delete folder
          const { folderId } = editDragData;
          const category = categories.find(c => c.id === folderId);
          if (category && confirm(`Delete folder "${category.label}" and all its phrases?`)) {
            categories = categories.filter(c => c.id !== folderId);
            delete library[folderId];
            delete slots[folderId];
            showToast('Folder deleted');
          }
        }
        
        saveToStorage();
        renderLibrary();
        renderSlots();
        renderPreview();
        cleanupDrag();
        return;
      }
      
      // Check if reordering
      if (editDragType === 'phrase') {
        // Check if dropped on another phrase in same category
        dragGhost.style.display = 'none';
        const elementBelow = document.elementFromPoint(x, y);
        dragGhost.style.display = 'block';
        
        const targetChip = elementBelow?.closest('.phrase-chip:not(.picked-up)');
        if (targetChip && targetChip.dataset.category === editDragData.categoryId) {
          const targetIndex = parseInt(targetChip.dataset.index);
          const sourceIndex = editDragData.index;
          
          if (targetIndex !== sourceIndex) {
            // Reorder phrases
            const phrases = library[editDragData.categoryId];
            const [removed] = phrases.splice(sourceIndex, 1);
            phrases.splice(targetIndex, 0, removed);
            
            saveToStorage();
            renderLibrary();
          }
        }
      } else if (editDragType === 'folder') {
        // Check if dropped on another folder
        dragGhost.style.display = 'none';
        const elementBelow = document.elementFromPoint(x, y);
        dragGhost.style.display = 'block';
        
        const targetCategory = elementBelow?.closest('.library-category');
        if (targetCategory && targetCategory.dataset.categoryId !== editDragData.folderId) {
          const targetId = targetCategory.dataset.categoryId;
          const sourceIndex = categories.findIndex(c => c.id === editDragData.folderId);
          const targetIndex = categories.findIndex(c => c.id === targetId);
          
          if (sourceIndex !== -1 && targetIndex !== -1) {
            // Reorder folders
            const [removed] = categories.splice(sourceIndex, 1);
            categories.splice(targetIndex, 0, removed);
            
            saveToStorage();
            renderLibrary();
            renderSlots();
            renderPreview();
          }
        }
      }
      
      cleanupDrag();
    }
    
    function updateEditDropTarget(x, y) {
      // Clear previous highlights
      document.querySelectorAll('.drag-over-folder, .drag-over-folder-below').forEach(el => {
        el.classList.remove('drag-over-folder', 'drag-over-folder-below');
      });
      
      const trashTarget = document.getElementById('trashBinTarget');
      const trashRect = trashTarget.getBoundingClientRect();
      
      // Check if over trash
      if (x >= trashRect.left && x <= trashRect.right && y >= trashRect.top && y <= trashRect.bottom) {
        trashTarget.classList.add('drag-over');
      } else {
        trashTarget.classList.remove('drag-over');
        
        // Check if over a folder (for folder reordering)
        if (editDragType === 'folder') {
          dragGhost.style.display = 'none';
          const elementBelow = document.elementFromPoint(x, y);
          dragGhost.style.display = 'block';
          
          const targetCategory = elementBelow?.closest('.library-category');
          if (targetCategory && targetCategory.dataset.categoryId !== editDragData.folderId) {
            targetCategory.classList.add('drag-over-folder');
          }
        }
      }
    }
    
    // --- Utility functions ---
    function cancelPress() {
      if (pressTimer) {
        clearTimeout(pressTimer);
        pressTimer = null;
      }
      if (pressStartChip) {
        pressStartChip.classList.remove('pressing');
        pressStartChip = null;
      }
    }
    
    function cleanupDrag() {
      isDragging = false;
      editDragType = null;
      editDragData = null;
      
      dragGhost.style.display = 'none';
      dragGhost.classList.remove('dropping');
      
      if (dragData && dragData.sourceChip) {
        dragData.sourceChip.classList.remove('picked-up');
      }
      
      document.querySelectorAll('.prompt-slot').forEach(slot => {
        slot.classList.remove('drag-hover', 'tap-ready');
      });
      
      document.querySelectorAll('.category-header').forEach(header => {
        header.classList.remove('dragging-folder');
      });
      
      document.querySelectorAll('.library-category').forEach(cat => {
        cat.classList.remove('drag-over-folder', 'drag-over-folder-below');
      });
      
      document.getElementById('trashBinTarget')?.classList.remove('drag-over');
      
      dragData = null;
    }
    
    function highlightValidSlots(categoryId) {
      document.querySelectorAll('.prompt-slot').forEach(slot => {
        if (slot.dataset.category === categoryId) {
          slot.classList.add('tap-ready');
        }
      });
    }
    
    function updateDropTarget(x, y) {
      document.querySelectorAll('.prompt-slot.drag-hover').forEach(slot => {
        slot.classList.remove('drag-hover');
      });
      
      const target = getDropTarget(x, y);
      if (target && dragData && target.categoryId === dragData.categoryId) {
        target.element.classList.add('drag-hover');
      }
    }
    
    function getDropTarget(x, y) {
      dragGhost.style.display = 'none';
      const elementBelow = document.elementFromPoint(x, y);
      dragGhost.style.display = 'block';
      
      if (!elementBelow) return null;
      
      const slot = elementBelow.closest('.prompt-slot');
      if (slot) {
        return {
          element: slot,
          categoryId: slot.dataset.category
        };
      }
      
      return null;
    }
    
    // ============ COPY ============
    function copyPrompt() {
      const preview = document.getElementById('previewContent');
      const copyBtn = document.getElementById('copyBtn');
      // Use stored plain text (without HTML formatting)
      const text = preview.dataset.plainText || preview.textContent;
      
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text)
          .then(() => {
            showToast('‚úì Copied to clipboard!');
            animateCopyButton(copyBtn);
          })
          .catch(() => {
            fallbackCopy(text, copyBtn);
          });
      } else {
        fallbackCopy(text, copyBtn);
      }
    }
    
    function fallbackCopy(text, copyBtn) {
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.left = '-9999px';
      textArea.style.top = '0';
      textArea.setAttribute('readonly', '');
      document.body.appendChild(textArea);
      
      textArea.focus();
      textArea.select();
      textArea.setSelectionRange(0, text.length);
      
      try {
        document.execCommand('copy');
        showToast('‚úì Copied to clipboard!');
        animateCopyButton(copyBtn);
      } catch (err) {
        showToast('‚ö† Could not copy');
      }
      
      document.body.removeChild(textArea);
    }
    
    function animateCopyButton(btn) {
      btn.textContent = '‚úì Copied!';
      btn.classList.add('copied');
      setTimeout(() => {
        btn.textContent = 'üìã Copy';
        btn.classList.remove('copied');
      }, 2000);
    }
    
    function showToast(message) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.classList.remove('hide');
      toast.classList.add('show');
      
      if (navigator.vibrate) {
        navigator.vibrate(30);
      }
      
      setTimeout(() => {
        toast.classList.remove('show');
        toast.classList.add('hide');
      }, 1500);
    }
    
    // ============ TEMPLATES ============
    function showSaveForm() {
      document.getElementById('saveForm').classList.add('active');
      document.getElementById('saveBtn').style.display = 'none';
      document.getElementById('saveNameInput').focus();
    }
    
    function hideSaveForm() {
      document.getElementById('saveForm').classList.remove('active');
      document.getElementById('saveBtn').style.display = 'block';
      document.getElementById('saveNameInput').value = '';
    }
    
    function saveTemplate() {
      const name = document.getElementById('saveNameInput').value.trim();
      if (!name) return;
      
      const template = {
        name,
        slots: JSON.parse(JSON.stringify(slots)),
        references: references.map(r => ({ image: null, role: r.role }))
      };
      
      templates = templates.filter(t => t.name !== name);
      templates.push(template);
      
      currentTemplateName = name;
      document.getElementById('templateCurrent').textContent = `üìÑ ${name}`;
      
      saveToStorage();
      renderTemplateSelect();
      hideSaveForm();
      showToast('Template saved!');
    }
    
    function loadTemplate(name) {
      if (!name) return;
      
      const template = templates.find(t => t.name === name);
      if (!template) return;
      
      slots = JSON.parse(JSON.stringify(template.slots));
      
      // Make sure all current categories have a slot
      categories.forEach(cat => {
        if (!slots[cat.id]) slots[cat.id] = [];
      });
      
      if (template.references) {
        references = template.references.map(r => ({ image: null, role: r.role }));
      }
      
      currentTemplateName = name;
      document.getElementById('templateCurrent').textContent = `üìÑ ${name}`;
      document.getElementById('templateSelect').value = '';
      
      renderSlots();
      renderReferences();
      renderPreview();
    }
    
    // ============ SETTINGS ============
    let generationMode = localStorage.getItem('generationMode') || 'sequential';
    let currentTheme = localStorage.getItem('appTheme') || 'dark';
    
    function openSettings() {
      updateSettingsUI();
      document.getElementById('settingsOverlay').classList.add('active');
      document.getElementById('settingsModal').classList.add('active');
    }
    
    function closeSettings() {
      document.getElementById('settingsOverlay').classList.remove('active');
      document.getElementById('settingsModal').classList.remove('active');
      
      // Close any open input rows
      document.querySelectorAll('.settings-api-input-row').forEach(row => {
        row.classList.remove('active');
      });
    }
    
    function updateSettingsUI() {
      // Update Anthropic API key status (assistant uses 'claudeApiKey')
      const anthropicKey = localStorage.getItem('claudeApiKey');
      const anthropicStatus = document.getElementById('settingsAnthropicStatus');
      const anthropicBtn = document.getElementById('settingsAnthropicBtn');
      
      if (anthropicKey) {
        anthropicStatus.textContent = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢' + anthropicKey.slice(-4);
        anthropicStatus.classList.add('set');
        anthropicStatus.classList.remove('not-set');
        anthropicBtn.textContent = 'Remove';
        anthropicBtn.classList.add('remove');
      } else {
        anthropicStatus.textContent = 'Not set';
        anthropicStatus.classList.remove('set');
        anthropicStatus.classList.add('not-set');
        anthropicBtn.textContent = 'Add';
        anthropicBtn.classList.remove('remove');
      }
      
      // Update Google API key status
      const googleKey = localStorage.getItem('googleApiKey');
      const googleStatus = document.getElementById('settingsGoogleStatus');
      const googleBtn = document.getElementById('settingsGoogleBtn');
      
      if (googleKey) {
        googleStatus.textContent = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢' + googleKey.slice(-4);
        googleStatus.classList.add('set');
        googleStatus.classList.remove('not-set');
        googleBtn.textContent = 'Remove';
        googleBtn.classList.add('remove');
      } else {
        googleStatus.textContent = 'Not set';
        googleStatus.classList.remove('set');
        googleStatus.classList.add('not-set');
        googleBtn.textContent = 'Add';
        googleBtn.classList.remove('remove');
      }
      
      // Update generation mode
      document.querySelectorAll('.settings-radio-option').forEach(opt => {
        opt.classList.toggle('selected', opt.dataset.mode === generationMode);
      });
      
      // Update theme
      document.querySelectorAll('.settings-theme-option').forEach(opt => {
        opt.classList.toggle('selected', opt.dataset.theme === currentTheme);
      });
    }
    
    function toggleApiKeyInput(type) {
      const btn = document.getElementById(`settings${type.charAt(0).toUpperCase() + type.slice(1)}Btn`);
      const inputRow = document.getElementById(`${type}InputRow`);
      const key = localStorage.getItem(type === 'anthropic' ? 'claudeApiKey' : 'googleApiKey');
      
      if (key) {
        // Remove the key
        if (confirm(`Remove ${type === 'anthropic' ? 'Anthropic' : 'Google AI'} API key?`)) {
          localStorage.removeItem(type === 'anthropic' ? 'claudeApiKey' : 'googleApiKey');
          updateSettingsUI();
          
          // Update other UI elements
          if (type === 'anthropic') {
            document.getElementById('apiKeySetup').style.display = 'flex';
            document.getElementById('assistantMessages').style.display = 'none';
            document.getElementById('assistantInputArea').style.display = 'none';
          } else {
            updateImageGeneratorUI();
          }
          
          showToast(`üîë ${type === 'anthropic' ? 'Anthropic' : 'Google AI'} key removed`);
        }
      } else {
        // Toggle input row
        inputRow.classList.toggle('active');
      }
    }
    
    function saveSettingsApiKey(type) {
      const input = document.getElementById(`settings${type.charAt(0).toUpperCase() + type.slice(1)}Input`);
      const key = input.value.trim();
      
      if (type === 'anthropic') {
        if (!key || !key.startsWith('sk-ant-')) {
          showToast('‚ö†Ô∏è Invalid Anthropic key (should start with sk-ant-)');
          return;
        }
        localStorage.setItem('claudeApiKey', key);
        
        // Update assistant UI
        document.getElementById('apiKeySetup').style.display = 'none';
        document.getElementById('assistantMessages').style.display = 'flex';
        document.getElementById('assistantInputArea').style.display = 'flex';
        
      } else if (type === 'google') {
        if (!key || !key.startsWith('AIza')) {
          showToast('‚ö†Ô∏è Invalid Google key (should start with AIza)');
          return;
        }
        localStorage.setItem('googleApiKey', key);
        updateImageGeneratorUI();
      }
      
      input.value = '';
      document.getElementById(`${type}InputRow`).classList.remove('active');
      updateSettingsUI();
      showToast(`üîë ${type === 'anthropic' ? 'Anthropic' : 'Google AI'} key saved`);
    }
    
    function setGenerationMode(mode) {
      generationMode = mode;
      localStorage.setItem('generationMode', mode);
      
      document.querySelectorAll('.settings-radio-option').forEach(opt => {
        opt.classList.toggle('selected', opt.dataset.mode === mode);
      });
      
      showToast(`üé® Generation mode: ${mode === 'sequential' ? 'Sequential' : 'Parallel'}`);
    }
    
    function setTheme(theme) {
      // Only dark theme is currently implemented
      if (theme !== 'dark') {
        showToast('üé≠ Theme coming soon!');
        return;
      }
      
      currentTheme = theme;
      localStorage.setItem('appTheme', theme);
      
      document.querySelectorAll('.settings-theme-option').forEach(opt => {
        opt.classList.toggle('selected', opt.dataset.theme === theme);
      });
    }
    
    function resetBlueprintsToDefault() {
      if (!confirm('Reset all blueprints to default?\n\nThis will:\n‚Ä¢ Remove all custom blueprints\n‚Ä¢ Restore default blueprints\n‚Ä¢ Clear your current prompt\n\nThis cannot be undone.')) return;
      
      // Reset to defaults
      customBlueprints = [];
      categories = [...DEFAULT_CATEGORIES];
      library = JSON.parse(JSON.stringify(DEFAULT_PHRASES));
      slots = {};
      categories.forEach(cat => { slots[cat.id] = []; });
      currentBlueprintId = 'portrait';
      deletedItems = { folders: [], blueprints: [] };
      
      saveToStorage();
      renderLibrary();
      renderSlots();
      renderPreview();
      updateBlueprintButton();
      
      showToast('üîÑ Blueprints reset to default');
    }
    
    function clearAllData() {
      if (!confirm('Clear ALL data?\n\nThis will delete:\n‚Ä¢ All blueprints and folders\n‚Ä¢ All generated images\n‚Ä¢ All API keys\n‚Ä¢ All settings\n\nThis cannot be undone!')) return;
      
      if (!confirm('Are you absolutely sure? This is permanent.')) return;
      
      // Clear localStorage
      localStorage.clear();
      
      // Clear IndexedDB
      if (galleryDB) {
        galleryDB.close();
      }
      indexedDB.deleteDatabase('NanoBananaGallery');
      
      showToast('üóëÔ∏è All data cleared. Refreshing...');
      
      setTimeout(() => {
        location.reload();
      }, 1500);
    }
    
    // ============ EMOJI PICKER ============
    document.getElementById('emojiPicker').addEventListener('click', (e) => {
      const option = e.target.closest('.emoji-option');
      if (option) {
        selectedEmoji = option.dataset.emoji;
        updateEmojiSelection();
      }
    });
    
    document.getElementById('newFolderName').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') createNewFolder();
      if (e.key === 'Escape') closeFolderModal();
    });
    
    // ============ INIT ============
    document.getElementById('imageInput').addEventListener('change', handleImageSelect);
    document.getElementById('saveNameInput').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') saveTemplate();
      if (e.key === 'Escape') hideSaveForm();
    });
    
    // Handle folder color button - must intercept touch events before folder drag system
    document.addEventListener('touchstart', (e) => {
      const colorBtn = e.target.closest('.folder-color-btn');
      const actionBtn = e.target.closest('.folder-action-btn');
      const folderLabel = editMode && e.target.closest('.folder-label');
      if (colorBtn || actionBtn || folderLabel) {
        e.preventDefault();
        e.stopPropagation();
      }
    }, { capture: true, passive: false });
    
    document.addEventListener('touchend', (e) => {
      const colorBtn = e.target.closest('.folder-color-btn');
      if (colorBtn) {
        e.preventDefault();
        e.stopPropagation();
        const categoryId = colorBtn.dataset.categoryId;
        if (categoryId) {
          openColorPicker(categoryId);
        }
        return;
      }
      
      const actionBtn = e.target.closest('.folder-action-btn');
      if (actionBtn) {
        e.preventDefault();
        e.stopPropagation();
        const categoryId = actionBtn.dataset.categoryId;
        if (categoryId) {
          if (actionBtn.classList.contains('duplicate')) {
            duplicateFolder(categoryId);
          } else if (actionBtn.classList.contains('delete')) {
            deleteFolder(categoryId);
          }
        }
        return;
      }
      
      // Rename on label tap in edit mode
      if (editMode) {
        const folderLabel = e.target.closest('.folder-label');
        if (folderLabel) {
          e.preventDefault();
          e.stopPropagation();
          const categoryId = folderLabel.dataset.categoryId;
          if (categoryId) {
            renameFolder(categoryId);
          }
        }
      }
    }, { capture: true, passive: false });
    
    document.addEventListener('click', (e) => {
      const colorBtn = e.target.closest('.folder-color-btn');
      if (colorBtn) {
        e.preventDefault();
        e.stopPropagation();
        const categoryId = colorBtn.dataset.categoryId;
        if (categoryId) {
          openColorPicker(categoryId);
        }
        return;
      }
      
      const actionBtn = e.target.closest('.folder-action-btn');
      if (actionBtn) {
        e.preventDefault();
        e.stopPropagation();
        const categoryId = actionBtn.dataset.categoryId;
        if (categoryId) {
          if (actionBtn.classList.contains('duplicate')) {
            duplicateFolder(categoryId);
          } else if (actionBtn.classList.contains('delete')) {
            deleteFolder(categoryId);
          }
        }
        return;
      }
      
      // Rename on label click in edit mode
      if (editMode) {
        const folderLabel = e.target.closest('.folder-label');
        if (folderLabel) {
          e.preventDefault();
          e.stopPropagation();
          const categoryId = folderLabel.dataset.categoryId;
          if (categoryId) {
            renameFolder(categoryId);
          }
        }
      }
    }, { capture: true });
    
    // Handle color option selection - works with the global modal
    function handleColorOptionSelect(e) {
      const colorOption = e.target.closest('.color-option');
      if (colorOption && activeColorPicker) {
        e.preventDefault();
        e.stopPropagation();
        
        const color = colorOption.dataset.color;
        if (color) {
          setFolderColor(activeColorPicker, color);
        }
      }
    }
    
    // Color picker grid - touch and click
    document.getElementById('colorPickerGrid').addEventListener('click', handleColorOptionSelect);
    document.getElementById('colorPickerGrid').addEventListener('touchend', (e) => {
      e.preventDefault();
      handleColorOptionSelect(e);
    }, { passive: false });
    
    // Close color picker when clicking overlay
    document.getElementById('colorPickerOverlay').addEventListener('click', closeColorPicker);
    document.getElementById('colorPickerOverlay').addEventListener('touchend', (e) => {
      e.preventDefault();
      closeColorPicker();
    }, { passive: false });
    
    // Blueprint modal handlers
    document.getElementById('blueprintOverlay').addEventListener('click', closeBlueprintModal);
    document.getElementById('blueprintOverlay').addEventListener('touchend', (e) => {
      e.preventDefault();
      closeBlueprintModal();
    }, { passive: false });
    
    // Blueprint card clicks
    document.getElementById('blueprintGrid').addEventListener('click', (e) => {
      // Prevent card click when clicking on actions row
      if (e.target.closest('.blueprint-card-actions')) {
        const btn = e.target.closest('button');
        if (!btn) {
          e.stopPropagation();
          return;
        }
      }
      
      const exportBtn = e.target.closest('.blueprint-export-btn');
      if (exportBtn) {
        e.stopPropagation();
        const blueprintId = exportBtn.dataset.blueprintId;
        if (blueprintId) exportBlueprint(blueprintId);
        return;
      }
      
      const duplicateBtn = e.target.closest('.blueprint-duplicate-btn');
      if (duplicateBtn) {
        e.stopPropagation();
        const blueprintId = duplicateBtn.dataset.blueprintId;
        if (blueprintId) duplicateBlueprint(blueprintId);
        return;
      }
      
      const deleteBtn = e.target.closest('.blueprint-delete-btn');
      if (deleteBtn) {
        e.stopPropagation();
        const blueprintId = deleteBtn.dataset.blueprintId;
        if (blueprintId) deleteBlueprint(blueprintId);
        return;
      }
      
      const card = e.target.closest('.blueprint-card');
      if (card) {
        const blueprintId = card.dataset.blueprintId;
        if (blueprintId) loadBlueprint(blueprintId);
      }
    });
    
    document.getElementById('blueprintGrid').addEventListener('touchend', (e) => {
      // Prevent card click when clicking on actions row
      if (e.target.closest('.blueprint-card-actions')) {
        const btn = e.target.closest('button');
        if (!btn) {
          e.preventDefault();
          e.stopPropagation();
          return;
        }
      }
      
      const exportBtn = e.target.closest('.blueprint-export-btn');
      if (exportBtn) {
        e.preventDefault();
        e.stopPropagation();
        const blueprintId = exportBtn.dataset.blueprintId;
        if (blueprintId) exportBlueprint(blueprintId);
        return;
      }
      
      const duplicateBtn = e.target.closest('.blueprint-duplicate-btn');
      if (duplicateBtn) {
        e.preventDefault();
        e.stopPropagation();
        const blueprintId = duplicateBtn.dataset.blueprintId;
        if (blueprintId) duplicateBlueprint(blueprintId);
        return;
      }
      
      const deleteBtn = e.target.closest('.blueprint-delete-btn');
      if (deleteBtn) {
        e.preventDefault();
        e.stopPropagation();
        const blueprintId = deleteBtn.dataset.blueprintId;
        if (blueprintId) deleteBlueprint(blueprintId);
        return;
      }
      
      const card = e.target.closest('.blueprint-card');
      if (card) {
        e.preventDefault();
        const blueprintId = card.dataset.blueprintId;
        if (blueprintId) loadBlueprint(blueprintId);
      }
    }, { passive: false });
    
    // Add Folder modal handlers
    document.getElementById('addFolderOverlay').addEventListener('click', closeAddFolderModal);
    document.getElementById('addFolderOverlay').addEventListener('touchend', (e) => {
      e.preventDefault();
      closeAddFolderModal();
    }, { passive: false });
    
    // Add Folder item clicks
    document.getElementById('addFolderGrid').addEventListener('click', (e) => {
      const item = e.target.closest('.add-folder-item');
      if (item && !item.classList.contains('already-added')) {
        const folderId = item.dataset.folderId;
        const label = item.dataset.folderLabel;
        const icon = item.dataset.folderIcon;
        const color = item.dataset.folderColor;
        if (folderId) addFolderFromBlueprint(folderId, label, icon, color);
      }
    });
    
    document.getElementById('addFolderGrid').addEventListener('touchend', (e) => {
      const item = e.target.closest('.add-folder-item');
      if (item && !item.classList.contains('already-added')) {
        e.preventDefault();
        const folderId = item.dataset.folderId;
        const label = item.dataset.folderLabel;
        const icon = item.dataset.folderIcon;
        const color = item.dataset.folderColor;
        if (folderId) addFolderFromBlueprint(folderId, label, icon, color);
      }
    }, { passive: false });
    
    // ============ IMAGE GENERATOR (Nano Banana Pro) ============
    let generatedImages = [];
    let isGenerating = false;
    let generationQueue = []; // Queue for sequential mode
    let imageGenBatchSize = 1;
    let galleryDB = null;
    
    // ============ INDEXEDDB GALLERY STORAGE ============
    const DB_NAME = 'NanoBananaGallery';
    const DB_VERSION = 1;
    const STORE_NAME = 'images';
    
    async function initGalleryDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        
        request.onerror = () => reject(request.error);
        
        request.onsuccess = () => {
          galleryDB = request.result;
          resolve(galleryDB);
        };
        
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            const store = db.createObjectStore(STORE_NAME, { keyPath: 'id' });
            store.createIndex('timestamp', 'timestamp', { unique: false });
            store.createIndex('status', 'status', { unique: false });
          }
        };
      });
    }
    
    async function loadGalleryFromStorage() {
      try {
        // Initialize IndexedDB
        if (!galleryDB) {
          await initGalleryDB();
        }
        
        // Check for localStorage migration first
        const legacyData = localStorage.getItem('nanoBananaGallery');
        if (legacyData) {
          const legacyImages = JSON.parse(legacyData);
          if (legacyImages.length > 0) {
            console.log('Migrating', legacyImages.length, 'images from localStorage to IndexedDB...');
            for (const img of legacyImages) {
              await saveImageToDB(img);
            }
            localStorage.removeItem('nanoBananaGallery');
            console.log('Migration complete!');
            showToast('üì¶ Gallery migrated to better storage!');
          }
        }
        
        // Load from IndexedDB
        generatedImages = await loadAllImagesFromDB();
        updateStorageIndicator();
        
      } catch (e) {
        console.error('Gallery load error:', e);
        generatedImages = [];
      }
    }
    
    async function saveGalleryToStorage() {
      try {
        // Save all current images to IndexedDB
        for (const img of generatedImages) {
          await saveImageToDB(img);
        }
        
        // Clean up any images in DB that aren't in current array
        const dbImages = await loadAllImagesFromDB();
        const currentIds = new Set(generatedImages.map(i => i.id));
        for (const dbImg of dbImages) {
          if (!currentIds.has(dbImg.id)) {
            await deleteImageFromDB(dbImg.id);
          }
        }
        
        updateStorageIndicator();
      } catch (e) {
        console.error('Gallery save error:', e);
      }
    }
    
    async function saveImageToDB(image) {
      if (!galleryDB) await initGalleryDB();
      
      return new Promise((resolve, reject) => {
        const transaction = galleryDB.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.put(image);
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }
    
    async function loadAllImagesFromDB() {
      if (!galleryDB) await initGalleryDB();
      
      return new Promise((resolve, reject) => {
        const transaction = galleryDB.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.getAll();
        request.onsuccess = () => {
          // Sort by timestamp descending (newest first)
          const images = request.result.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
          resolve(images);
        };
        request.onerror = () => reject(request.error);
      });
    }
    
    async function deleteImageFromDB(id) {
      if (!galleryDB) await initGalleryDB();
      
      return new Promise((resolve, reject) => {
        const transaction = galleryDB.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.delete(id);
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }
    
    async function getGalleryStorageSize() {
      if (!galleryDB) await initGalleryDB();
      
      return new Promise((resolve) => {
        const transaction = galleryDB.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.getAll();
        
        request.onsuccess = () => {
          let totalBytes = 0;
          for (const img of request.result) {
            // Estimate size: base64 data + metadata
            if (img.data) {
              totalBytes += img.data.length * 0.75; // base64 to bytes
            }
            totalBytes += JSON.stringify(img).length - (img.data?.length || 0);
          }
          resolve({
            bytes: totalBytes,
            count: request.result.length,
            formatted: formatBytes(totalBytes)
          });
        };
        
        request.onerror = () => resolve({ bytes: 0, count: 0, formatted: '0 B' });
      });
    }
    
    function formatBytes(bytes) {
      if (bytes === 0) return '0 B';
      const k = 1024;
      const sizes = ['B', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
    }
    
    async function updateStorageIndicator() {
      const indicator = document.getElementById('galleryStorageIndicator');
      if (!indicator) return;
      
      const storage = await getGalleryStorageSize();
      indicator.innerHTML = `üìä ${storage.count} images ¬∑ ${storage.formatted}`;
    }
    
    function getGoogleApiKey() {
      return localStorage.getItem('googleApiKey') || '';
    }
    
    function saveGoogleApiKey() {
      const key = document.getElementById('googleApiKeyInput').value.trim();
      if (!key || !key.startsWith('AIza')) {
        showToast('Invalid API key');
        return;
      }
      localStorage.setItem('googleApiKey', key);
      document.getElementById('googleApiKeyInput').value = '';
      updateImageGeneratorUI();
      showToast('API key saved!');
    }
    
    function toggleImageGenerator() {
      document.getElementById('imageGenOverlay').classList.add('active');
      document.getElementById('imageGenModal').classList.add('active');
      updateImageGeneratorUI();
      renderGallery();
      updateStorageIndicator();
      
      // Restore saved slider value
      const savedSize = localStorage.getItem('galleryItemSize') || '150';
      const slider = document.getElementById('gallerySizeSlider');
      if (slider) {
        slider.value = savedSize;
        updateGallerySize(savedSize);
      }
    }
    
    function closeImageGenerator() {
      document.getElementById('imageGenOverlay').classList.remove('active');
      document.getElementById('imageGenModal').classList.remove('active');
    }
    
    function openGalleryOnly() {
      // Opens the Image Generator modal (which contains the gallery)
      document.getElementById('imageGenOverlay').classList.add('active');
      document.getElementById('imageGenModal').classList.add('active');
      updateImageGeneratorUI();
      renderGallery();
      updateStorageIndicator();
      
      // Restore saved slider value
      const savedSize = localStorage.getItem('galleryItemSize') || '150';
      const slider = document.getElementById('gallerySizeSlider');
      if (slider) {
        slider.value = savedSize;
        updateGallerySize(savedSize);
      }
    }
    
    function updateGallerySize(value) {
      const grid = document.getElementById('galleryGrid');
      if (grid) {
        grid.style.setProperty('--gallery-item-size', value + 'px');
      }
      // Save preference
      localStorage.setItem('galleryItemSize', value);
    }
    
    function updateImageGeneratorUI() {
      const hasKey = !!getGoogleApiKey();
      document.getElementById('imageGenApiSetup').style.display = hasKey ? 'none' : 'flex';
      document.getElementById('imageGenSettings').style.display = hasKey ? 'flex' : 'none';
      document.getElementById('imageGenActions').style.display = hasKey ? 'block' : 'none';
      
      const preview = document.getElementById('previewContent');
      const promptPreview = document.getElementById('imageGenPromptPreview');
      const plainText = preview.dataset.plainText || preview.textContent;
      
      if (plainText.includes('Start adding')) {
        promptPreview.textContent = 'Build your prompt first...';
      } else {
        // Use the colored HTML from the preview panel
        promptPreview.innerHTML = preview.innerHTML;
      }
    }
    
    function selectBatchSize(count) {
      imageGenBatchSize = count;
      document.querySelectorAll('.batch-option').forEach(btn => {
        btn.classList.toggle('selected', parseInt(btn.dataset.count) === count);
      });
    }
    
    async function generateImages() {
      const apiKey = getGoogleApiKey();
      if (!apiKey) { showToast('Add API key first'); return; }
      
      const preview = document.getElementById('previewContent');
      const prompt = preview.dataset.plainText || preview.textContent;
      if (!prompt || prompt.includes('Start adding')) {
        showToast('Build a prompt first!');
        return;
      }
      
      const model = document.getElementById('modelSelect').value;
      const aspectRatio = document.getElementById('aspectRatioSelect').value;
      const resolution = document.getElementById('resolutionSelect').value;
      
      // Create generation request
      const genRequest = {
        prompt,
        model,
        aspectRatio,
        resolution,
        count: imageGenBatchSize
      };
      
      // Handle based on generation mode
      if (generationMode === 'parallel' || !isGenerating) {
        // Start generation immediately
        executeGeneration(genRequest);
      } else {
        // Queue for later (sequential mode and already generating)
        generationQueue.push(genRequest);
        showToast(`üìã Queued batch (${generationQueue.length} in queue)`);
        updateGenerateButtonState();
      }
    }
    
    async function executeGeneration(request) {
      const apiKey = getGoogleApiKey();
      isGenerating = true;
      updateGenerateButtonState();
      
      const { prompt, model, aspectRatio, resolution, count } = request;
      const timestamp = Date.now();
      
      // Step 1: Create ALL placeholders immediately
      const tempIds = [];
      for (let i = 0; i < count; i++) {
        const tempId = 'temp_' + timestamp + '_' + i;
        tempIds.push(tempId);
        generatedImages.unshift({ 
          id: tempId, 
          status: 'generating', 
          prompt, 
          settings: { aspectRatio, resolution, model } 
        });
      }
      renderGallery(); // Show all placeholders at once!
      
      // Step 2: Generate all images in parallel with staggered starts
      const generateSingle = async (tempId, index) => {
        // Stagger requests slightly to avoid rate limiting
        if (index > 0) {
          await new Promise(r => setTimeout(r, index * 300));
        }
        
        try {
          const requestBody = {
            contents: [{ parts: [{ text: prompt }] }],
            generationConfig: {
              responseModalities: ['IMAGE', 'TEXT']
            }
          };
          
          if (aspectRatio !== '1:1' || resolution !== '1K') {
            requestBody.generationConfig.imageConfig = {};
            if (aspectRatio !== '1:1') {
              requestBody.generationConfig.imageConfig.aspectRatio = aspectRatio;
            }
            if (resolution !== '1K') {
              requestBody.generationConfig.imageConfig.imageSize = resolution;
            }
          }
          
          const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
          });
          
          const data = await response.json();
          const idx = generatedImages.findIndex(img => img.id === tempId);
          if (idx === -1) return;
          
          if (data.candidates?.[0]?.content?.parts) {
            const imagePart = data.candidates[0].content.parts.find(p => p.inlineData);
            if (imagePart) {
              generatedImages[idx] = {
                id: 'img_' + Date.now() + '_' + index,
                status: 'success',
                data: imagePart.inlineData.data,
                prompt,
                settings: { aspectRatio, resolution, model },
                timestamp: Date.now()
              };
            } else {
              generatedImages[idx] = { ...generatedImages[idx], status: 'error', error: 'No image returned' };
            }
          } else {
            const errorMsg = data.error?.message || 'Generation failed';
            let displayError = errorMsg;
            if (errorMsg.includes('overloaded') || errorMsg.includes('503')) {
              displayError = 'Model busy, try again';
            } else if (errorMsg.includes('quota') || errorMsg.includes('429')) {
              displayError = 'Rate limited, wait a bit';
            } else if (errorMsg.includes('SAFETY')) {
              displayError = 'Blocked by safety filter';
            }
            generatedImages[idx] = { ...generatedImages[idx], status: 'error', error: displayError };
          }
        } catch (e) {
          const idx = generatedImages.findIndex(img => img.id === tempId);
          if (idx !== -1) {
            generatedImages[idx] = { ...generatedImages[idx], status: 'error', error: e.message };
          }
        }
        
        renderGallery();
        saveGalleryToStorage();
      };
      
      // Fire all generations in parallel
      await Promise.allSettled(tempIds.map((id, i) => generateSingle(id, i)));
      
      isGenerating = false;
      
      // Show completion toast
      const successCount = tempIds.filter(id => 
        generatedImages.find(img => img.id?.startsWith('img_') && img.prompt === prompt)
      ).length;
      if (successCount > 0) {
        showToast(`üçå Generated ${successCount} image${successCount > 1 ? 's' : ''}!`);
      }
      
      // Process queue if there are pending items (sequential mode)
      if (generationQueue.length > 0 && generationMode === 'sequential') {
        const nextRequest = generationQueue.shift();
        showToast(`üé® Starting queued batch (${generationQueue.length} remaining)`);
        executeGeneration(nextRequest);
      } else {
        updateGenerateButtonState();
      }
    }
    
    function updateGenerateButtonState() {
      const btn = document.getElementById('imageGenSubmit');
      if (!btn) return;
      
      if (isGenerating) {
        if (generationMode === 'sequential') {
          btn.disabled = false;
          btn.textContent = generationQueue.length > 0 
            ? `üìã Queue (${generationQueue.length})` 
            : 'üìã Add to Queue';
        } else {
          btn.disabled = false;
          btn.textContent = 'üé® Generate More';
        }
      } else {
        btn.disabled = false;
        btn.textContent = 'üé® Generate Images';
      }
    }
    
    // Helper to convert aspect ratio string to CSS value
    function getAspectRatioCss(ratioStr) {
      if (!ratioStr) return '1 / 1';
      const [w, h] = ratioStr.split(':').map(Number);
      return `${w} / ${h}`;
    }
    
    function renderGallery() {
      const grid = document.getElementById('galleryGrid');
      const successImages = generatedImages.filter(img => img.status === 'success');
      
      if (successImages.length === 0 && !generatedImages.some(img => img.status === 'generating')) {
        grid.innerHTML = '<div class="gallery-empty"><div class="gallery-empty-icon">üçå</div><div class="gallery-empty-text">No images yet</div></div>';
        return;
      }
      
      grid.innerHTML = generatedImages.map((img, index) => {
        const aspectRatio = img.settings?.aspectRatio || '1:1';
        const aspectCss = getAspectRatioCss(aspectRatio);
        
        if (img.status === 'generating') {
          return `<div class="image-card image-card-loading">
            <div class="loading-placeholder" style="aspect-ratio: ${aspectCss};">‚è≥</div>
          </div>`;
        } else if (img.status === 'error') {
          return `<div class="image-card image-card-error">
            <div class="error-placeholder" style="aspect-ratio: ${aspectCss};">
              <span class="error-icon">‚ö†Ô∏è</span>
              <span class="error-text">${img.error}</span>
              <button class="error-delete-btn" onclick="deleteFailedGeneration('${img.id}')">‚úï Remove</button>
            </div>
          </div>`;
        } else {
          return `<div class="image-card" onclick="openLightbox('${img.id}')" data-index="${index}">
            <img src="data:image/png;base64,${img.data}" alt="Generated image">
          </div>`;
        }
      }).join('');
    }
    
    // Share or Download - uses Web Share API if available (iOS can save to Photos)
    async function shareOrDownload(id) {
      const img = generatedImages.find(i => i.id === id);
      if (!img) return;
      
      try {
        // Convert base64 to blob
        const response = await fetch('data:image/png;base64,' + img.data);
        const blob = await response.blob();
        const file = new File([blob], 'nano-banana-' + Date.now() + '.png', { type: 'image/png' });
        
        // Check if Web Share API with files is supported
        if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
          await navigator.share({
            files: [file],
            title: 'Nano Banana Pro Image'
          });
          showToast('üì§ Share sheet opened!');
          return;
        }
      } catch (e) {
        console.log('Share failed, falling back to download:', e);
      }
      
      // Fallback to regular download
      downloadImage(id);
    }
    
    function downloadImage(id) {
      const img = generatedImages.find(i => i.id === id);
      if (!img) return;
      const a = document.createElement('a');
      a.href = 'data:image/png;base64,' + img.data;
      a.download = 'nano-banana-' + Date.now() + '.png';
      a.click();
      showToast('üíæ Downloaded!');
    }
    
    async function deleteImage(id) {
      generatedImages = generatedImages.filter(i => i.id !== id);
      await deleteImageFromDB(id);
      renderGallery();
      updateStorageIndicator();
    }
    
    async function deleteFailedGeneration(id) {
      generatedImages = generatedImages.filter(i => i.id !== id);
      await deleteImageFromDB(id);
      renderGallery();
      updateStorageIndicator();
      showToast('üóëÔ∏è Removed failed generation');
    }
    
    async function clearGallery() {
      if (confirm('Clear all images? This cannot be undone.')) {
        // Clear IndexedDB
        if (galleryDB) {
          try {
            const transaction = galleryDB.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            await new Promise((resolve, reject) => {
              const request = store.clear();
              request.onsuccess = () => resolve();
              request.onerror = () => reject(request.error);
            });
          } catch (e) {
            console.error('Error clearing gallery:', e);
          }
        }
        
        generatedImages = [];
        renderGallery();
        updateStorageIndicator();
        showToast('üóëÔ∏è Gallery cleared');
      }
    }
    
    // ============ LIGHTBOX WITH PINCH-TO-ZOOM ============
    let currentLightboxId = null;
    let currentLightboxIndex = 0;
    let lightboxScale = 1;
    let lightboxTranslateX = 0;
    let lightboxTranslateY = 0;
    let initialPinchDistance = 0;
    let initialScale = 1;
    let lastTapTime = 0;
    
    // Get only successful images for navigation
    function getSuccessImages() {
      return generatedImages.filter(img => img.status === 'success');
    }
    
    function openLightbox(id) {
      const successImages = getSuccessImages();
      const index = successImages.findIndex(i => i.id === id);
      if (index === -1) return;
      
      const img = successImages[index];
      currentLightboxId = id;
      currentLightboxIndex = index;
      lightboxScale = 1;
      lightboxTranslateX = 0;
      lightboxTranslateY = 0;
      
      const overlay = document.getElementById('lightboxOverlay');
      const image = document.getElementById('lightboxImage');
      const hint = document.getElementById('lightboxHint');
      
      image.src = 'data:image/png;base64,' + img.data;
      
      // Update info display
      updateLightboxInfo(img, index, successImages.length);
      
      // Update navigation buttons
      updateLightboxNav(index, successImages.length);
      
      // Reset transform
      updateLightboxTransform();
      
      // Show hint briefly
      hint.classList.remove('hidden');
      setTimeout(() => hint.classList.add('hidden'), 3000);
      
      overlay.classList.add('active');
      document.body.style.overflow = 'hidden';
      
      // Set up touch handlers
      setupLightboxGestures();
    }
    
    function updateLightboxInfo(img, index, total) {
      document.getElementById('lightboxCounter').textContent = `${index + 1} / ${total}`;
      const ratio = img.settings?.aspectRatio || '1:1';
      const res = img.settings?.resolution || '1K';
      document.getElementById('lightboxSettings').textContent = `${ratio} ‚Ä¢ ${res}`;
    }
    
    function updateLightboxNav(index, total) {
      document.getElementById('lightboxPrev').disabled = index === 0;
      document.getElementById('lightboxNext').disabled = index === total - 1;
    }
    
    function navigateLightbox(direction) {
      const successImages = getSuccessImages();
      const newIndex = currentLightboxIndex + direction;
      
      if (newIndex < 0 || newIndex >= successImages.length) return;
      
      const newImg = successImages[newIndex];
      currentLightboxId = newImg.id;
      currentLightboxIndex = newIndex;
      
      // Reset zoom
      lightboxScale = 1;
      lightboxTranslateX = 0;
      lightboxTranslateY = 0;
      updateLightboxTransform();
      
      // Update image with smooth transition
      const image = document.getElementById('lightboxImage');
      image.style.opacity = '0';
      setTimeout(() => {
        image.src = 'data:image/png;base64,' + newImg.data;
        image.style.opacity = '1';
      }, 100);
      
      // Update info and nav
      updateLightboxInfo(newImg, newIndex, successImages.length);
      updateLightboxNav(newIndex, successImages.length);
    }
    
    function closeLightbox() {
      document.getElementById('lightboxOverlay').classList.remove('active');
      document.body.style.overflow = '';
      currentLightboxId = null;
    }
    
    function updateLightboxTransform() {
      const wrapper = document.getElementById('lightboxWrapper');
      wrapper.style.transform = `translate(${lightboxTranslateX}px, ${lightboxTranslateY}px) scale(${lightboxScale})`;
    }
    
    function setupLightboxGestures() {
      const container = document.getElementById('lightboxContainer');
      
      // Touch handlers (using unique names to avoid conflict with drag-and-drop)
      container.ontouchstart = handleLightboxTouchStart;
      container.ontouchmove = handleLightboxTouchMove;
      container.ontouchend = handleLightboxTouchEnd;
      
      // Double-click to reset
      container.ondblclick = () => {
        lightboxScale = 1;
        lightboxTranslateX = 0;
        lightboxTranslateY = 0;
        updateLightboxTransform();
      };
    }
    
    function handleLightboxTouchStart(e) {
      if (e.touches.length === 2) {
        // Pinch start
        initialPinchDistance = getPinchDistance(e.touches);
        initialScale = lightboxScale;
        e.preventDefault();
      } else if (e.touches.length === 1) {
        // Check for double tap
        const now = Date.now();
        if (now - lastTapTime < 300) {
          // Double tap - reset zoom
          lightboxScale = 1;
          lightboxTranslateX = 0;
          lightboxTranslateY = 0;
          updateLightboxTransform();
          e.preventDefault();
        }
        lastTapTime = now;
      }
    }
    
    function handleLightboxTouchMove(e) {
      if (e.touches.length === 2) {
        // Pinch zoom
        const currentDistance = getPinchDistance(e.touches);
        const scale = (currentDistance / initialPinchDistance) * initialScale;
        lightboxScale = Math.max(0.5, Math.min(5, scale));
        updateLightboxTransform();
        e.preventDefault();
      } else if (e.touches.length === 1 && lightboxScale > 1) {
        // Pan when zoomed
        const touch = e.touches[0];
        lightboxTranslateX += touch.clientX - (e.target._lastX || touch.clientX);
        lightboxTranslateY += touch.clientY - (e.target._lastY || touch.clientY);
        e.target._lastX = touch.clientX;
        e.target._lastY = touch.clientY;
        updateLightboxTransform();
        e.preventDefault();
      }
    }
    
    function handleLightboxTouchEnd(e) {
      if (e.target._lastX) {
        e.target._lastX = null;
        e.target._lastY = null;
      }
      initialPinchDistance = 0;
    }
    
    function getPinchDistance(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }
    
    async function shareImage(id) {
      // Use passed id or fallback to lightbox id
      const imageId = id || currentLightboxId;
      if (!imageId) return;
      
      const img = generatedImages.find(i => i.id === imageId);
      if (!img) return;
      
      try {
        // Convert base64 to blob
        const response = await fetch('data:image/png;base64,' + img.data);
        const blob = await response.blob();
        const file = new File([blob], 'nano-banana-' + Date.now() + '.png', { type: 'image/png' });
        
        // Check if Web Share API with files is supported
        if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
          await navigator.share({
            files: [file],
            title: 'Nano Banana Pro Image'
          });
          showToast('üì§ Shared!');
          return;
        } else {
          showToast('üì§ Share not supported on this device');
        }
      } catch (e) {
        if (e.name !== 'AbortError') {
          showToast('üì§ Share cancelled');
        }
      }
    }
    
    function downloadLightboxImage() {
      if (currentLightboxId) {
        downloadImage(currentLightboxId);
      }
    }
    
    async function deleteFromLightbox() {
      if (!currentLightboxId) return;
      
      const successImages = getSuccessImages();
      const currentIndex = currentLightboxIndex;
      const idToDelete = currentLightboxId;
      
      // Delete the image
      generatedImages = generatedImages.filter(i => i.id !== idToDelete);
      await deleteImageFromDB(idToDelete);
      renderGallery();
      updateStorageIndicator();
      
      // Get new success images
      const newSuccessImages = getSuccessImages();
      
      if (newSuccessImages.length === 0) {
        // No more images, close lightbox
        closeLightbox();
        showToast('üóëÔ∏è Deleted');
        return;
      }
      
      // Navigate to next image, or previous if at end
      const newIndex = Math.min(currentIndex, newSuccessImages.length - 1);
      openLightbox(newSuccessImages[newIndex].id);
      showToast('üóëÔ∏è Deleted');
    }
    
    function openVisionChatFromLightbox() {
      if (!currentLightboxId) return;
      closeLightbox();
      openVisionChat(currentLightboxId);
    }
    
    function loadPromptFromImage() {
      if (!currentLightboxId) return;
      
      const img = generatedImages.find(i => i.id === currentLightboxId);
      if (!img) return;
      
      // Restore settings in the Image Generator
      if (img.settings) {
        if (img.settings.aspectRatio) {
          const aspectSelect = document.getElementById('aspectRatioSelect');
          if (aspectSelect) aspectSelect.value = img.settings.aspectRatio;
        }
        if (img.settings.resolution) {
          const resSelect = document.getElementById('resolutionSelect');
          if (resSelect) resSelect.value = img.settings.resolution;
        }
        if (img.settings.model) {
          const modelSelect = document.getElementById('modelSelect');
          if (modelSelect) modelSelect.value = img.settings.model;
        }
      }
      
      // Copy prompt to clipboard
      if (img.prompt) {
        navigator.clipboard.writeText(img.prompt).then(() => {
          showToast('üìã Prompt copied & settings loaded!');
        }).catch(() => {
          showToast('‚öôÔ∏è Settings loaded! Prompt: ' + img.prompt.substring(0, 50) + '...');
        });
      }
      
      // Close lightbox and open generator
      closeLightbox();
      toggleImageGenerator();
    }
    
    // Legacy compatibility
    function viewFullscreen(id) {
      openLightbox(id);
    }
    
    // ============ CLAUDE ASSISTANT ============
    let assistantActive = false;
    let chatHistory = [];
    let isWaitingForResponse = false;
    
    function getApiKey() { return localStorage.getItem('claudeApiKey') || ''; }
    
    function saveApiKey() {
      const key = document.getElementById('apiKeyInput').value.trim();
      if (!key.startsWith('sk-ant-')) { showToast('Invalid key'); return; }
      localStorage.setItem('claudeApiKey', key);
      document.getElementById('apiKeyInput').value = '';
      updateAssistantUI();
      showToast('API key saved!');
    }
    
    function toggleAssistant() {
      assistantActive = !assistantActive;
      const chatBtn = document.getElementById('chatToggleBtn');
      const previewContent = document.getElementById('previewContent');
      const templateBar = document.getElementById('templateBar');
      const assistantPanel = document.getElementById('assistantPanel');
      const copyBtn = document.getElementById('copyBtn');
      const previewTitle = document.getElementById('previewTitle');
      const generateBtn = document.getElementById('generateBtn');
      
      if (assistantActive) {
        chatBtn.classList.add('active');
        chatBtn.textContent = 'üìù Preview';
        previewContent.style.display = 'none';
        templateBar.style.display = 'none';
        assistantPanel.classList.add('active');
        copyBtn.style.display = 'none';
        generateBtn.style.display = 'none';
        previewTitle.textContent = 'ü§ñ Claude Assistant';
        updateAssistantUI();
      } else {
        chatBtn.classList.remove('active');
        chatBtn.textContent = 'ü§ñ Assistant';
        previewContent.style.display = 'block';
        templateBar.style.display = 'flex';
        assistantPanel.classList.remove('active');
        copyBtn.style.display = 'block';
        generateBtn.style.display = 'block';
        previewTitle.textContent = 'üìù Generated Prompt';
      }
    }
    
    function updateAssistantUI() {
      const hasKey = !!getApiKey();
      document.getElementById('apiKeySetup').style.display = hasKey ? 'none' : 'flex';
      document.getElementById('assistantMessages').style.display = hasKey ? 'flex' : 'none';
      document.getElementById('assistantInputArea').style.display = hasKey ? 'block' : 'none';
      
      // Load saved model preference
      const savedModel = localStorage.getItem('assistantModel') || 'claude-3-haiku-20240307';
      const modelSelect = document.getElementById('assistantModelSelect');
      if (modelSelect) modelSelect.value = savedModel;
    }
    
    function saveAssistantModel() {
      const modelSelect = document.getElementById('assistantModelSelect');
      if (modelSelect) {
        localStorage.setItem('assistantModel', modelSelect.value);
        showToast('Model: ' + modelSelect.options[modelSelect.selectedIndex].text);
      }
    }
    
    function getAssistantModel() {
      return localStorage.getItem('assistantModel') || 'claude-3-haiku-20240307';
    }
    
    function useCurrentPrompt() {
      const preview = document.getElementById('previewContent');
      const text = preview.dataset.plainText || preview.textContent;
      if (text && !text.includes('Start adding')) {
        document.getElementById('assistantInput').value = text;
        showToast('Prompt loaded');
      }
    }
    
    function clearChat() {
      chatHistory = [];
      document.getElementById('assistantMessages').innerHTML = '<div class="assistant-message system">üëã I\'m your prompt engineering co-pilot! I can:<br><br>‚Ä¢ üé® <strong>Create blueprints</strong> for any photography style<br>‚Ä¢ ‚ûï <strong>Add phrases</strong> to your folders<br>‚Ä¢ ‚ú® <strong>Suggest prompts</strong> and improvements<br>‚Ä¢ üìÅ <strong>Build custom folders</strong><br><br>Try: "Create a wildlife photography blueprint"</div>';
    }
    
    function useSuggestion(text) {
      document.getElementById('assistantInput').value = text;
      document.getElementById('assistantInput').focus();
    }
    
    async function sendToAssistant() {
      const input = document.getElementById('assistantInput');
      const msg = input.value.trim();
      if (!msg || isWaitingForResponse) return;
      
      const apiKey = getApiKey();
      if (!apiKey) { showToast('Add API key first'); return; }
      
      input.value = '';
      isWaitingForResponse = true;
      
      const container = document.getElementById('assistantMessages');
      container.innerHTML += `<div class="assistant-message user">${escapeHtml(msg)}</div>`;
      container.innerHTML += '<div class="assistant-message assistant typing-indicator" id="typingIndicator"><span></span><span></span><span></span></div>';
      container.scrollTop = container.scrollHeight;
      
      // Build context about current state
      let currentContext;
      try {
        currentContext = buildAssistantContext();
        console.log('Context built:', currentContext);
      } catch (contextError) {
        console.error('Context build error:', contextError);
        currentContext = { blueprint: 'Unknown', folders: [], currentPrompt: '', slotContents: [] };
      }
      
      chatHistory.push({ role: 'user', content: msg });
      
      // Create abort controller for timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 60000); // 60 second timeout
      
      try {
        console.log('Sending request to Anthropic API...');
        const selectedModel = getAssistantModel();
        console.log('Using model:', selectedModel);
        
        const response = await fetch('https://api.anthropic.com/v1/messages', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-api-key': apiKey,
            'anthropic-version': '2023-06-01',
            'anthropic-dangerous-direct-browser-access': 'true'
          },
          body: JSON.stringify({
            model: selectedModel,
            max_tokens: 2048,
            system: getAssistantSystemPrompt(currentContext),
            messages: chatHistory
          }),
          signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        console.log('Response received, status:', response.status);
        
        const data = await response.json();
        console.log('Response data:', data);
        
        document.getElementById('typingIndicator')?.remove();
        
        // Check for API errors first
        if (data.error) {
          chatHistory.pop(); // Remove the failed user message
          container.innerHTML += `<div class="assistant-message assistant">‚ö†Ô∏è API Error: ${data.error.message || JSON.stringify(data.error)}</div>`;
        } else if (data.content?.[0]?.text) {
          const reply = data.content[0].text;
          console.log('Got reply, length:', reply.length);
          chatHistory.push({ role: 'assistant', content: reply });
          
          // Parse and render the response with action blocks
          try {
            const renderedReply = parseAssistantResponse(reply);
            container.innerHTML += `<div class="assistant-message assistant">${renderedReply}</div>`;
          } catch (parseError) {
            console.error('Parse error:', parseError);
            container.innerHTML += `<div class="assistant-message assistant">${reply.replace(/\n/g, '<br>')}</div>`;
          }
        } else {
          chatHistory.pop(); // Remove the failed user message
          container.innerHTML += `<div class="assistant-message assistant">‚ö†Ô∏è Unexpected response. Check console for details.</div>`;
          console.log('Unexpected API response:', data);
        }
      } catch (e) {
        clearTimeout(timeoutId);
        document.getElementById('typingIndicator')?.remove();
        chatHistory.pop(); // Remove the failed user message
        
        if (e.name === 'AbortError') {
          container.innerHTML += `<div class="assistant-message assistant">‚ö†Ô∏è Request timed out. Please try again.</div>`;
        } else {
          container.innerHTML += `<div class="assistant-message assistant">‚ö†Ô∏è Error: ${e.message}</div>`;
        }
        console.error('Assistant error:', e);
      }
      
      isWaitingForResponse = false;
      container.scrollTop = container.scrollHeight;
    }
    
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    
    function buildAssistantContext() {
      // Gather current state for context
      const currentBlueprint = getCurrentBlueprintName();
      const folders = categories.map(c => ({
        id: c.id,
        label: c.label,
        icon: c.icon,
        phraseCount: library[c.id]?.length || 0,
        phrases: (library[c.id] || []).slice(0, 5) // First 5 phrases
      }));
      
      const currentPrompt = document.getElementById('previewContent')?.textContent || '';
      const slotContents = getSlotContents();
      
      return {
        blueprint: currentBlueprint,
        folders,
        currentPrompt,
        slotContents
      };
    }
    
    function getCurrentBlueprintName() {
      const btn = document.getElementById('blueprintBtn');
      return btn ? btn.textContent.trim() : 'Portrait';
    }
    
    function getSlotContents() {
      const slotContents = [];
      document.querySelectorAll('.prompt-slot').forEach(slot => {
        const categoryId = slot.dataset.category;
        const content = slot.querySelector('.slot-content')?.textContent?.trim();
        if (content && !content.includes('Drop') && !content.includes('empty')) {
          slotContents.push({ category: categoryId, content });
        }
      });
      return slotContents;
    }
    
    function getAssistantSystemPrompt(context) {
      return `You are an expert AI image prompt engineering assistant for "Prompt Blocks", a visual prompt builder app. Your role is to help users create, modify, and optimize prompt structures for AI image generation.

## CURRENT APPLICATION STATE
Blueprint: ${context.blueprint}
Available Folders: ${context.folders.map(f => `${f.icon} ${f.label} (${f.phraseCount} phrases)`).join(', ')}
Current Prompt: ${context.currentPrompt || '(empty)'}
Active Slots: ${context.slotContents.length > 0 ? context.slotContents.map(s => s.category + ': ' + s.content).join(' | ') : '(none)'}

## YOUR CAPABILITIES
You can generate structured actions that the app will render as interactive buttons:

### 1. CREATE A BLUEPRINT
When asked to create a blueprint for a photography style/genre, output:
\`\`\`BLUEPRINT
{
  "name": "Blueprint Name (NO emoji - text only)",
  "description": "Brief description",
  "icon": "emoji (single emoji for blueprint)",
  "folders": [
    {
      "id": "unique_id",
      "label": "Folder Name (NO emoji here - text only)", 
      "icon": "emoji (single emoji only)",
      "color": "#hexcolor",
      "phrases": ["phrase 1", "phrase 2", "phrase 3"]
    }
  ]
}
\`\`\`
IMPORTANT: The "name" and "label" fields must be plain text WITHOUT emojis. Put emojis ONLY in the "icon" fields.

### 2. ADD PHRASES TO A FOLDER
When asked to add phrases to a specific folder:
\`\`\`ADD_PHRASES
{
  "folderId": "folder_id",
  "folderLabel": "Folder Name",
  "phrases": ["new phrase 1", "new phrase 2"]
}
\`\`\`

### 3. SUGGEST A COMPLETE PROMPT
When asked to suggest or improve a prompt, provide the full text. The breakdown should use the EXACT folder IDs from the current state above (like "instruction", "subject", "environment", etc.):
\`\`\`PROMPT
{
  "text": "The complete prompt text here combining all parts",
  "breakdown": {
    "instruction": "Generate a cinematic photograph of",
    "subject": "a weathered fisherman",
    "environment": "on a misty pier at dawn",
    "lighting": "golden hour light with fog diffusion",
    "style": "documentary photography style"
  }
}
\`\`\`
IMPORTANT: Only include breakdown keys that match existing folder IDs in the current state. The breakdown lets users load parts into their slots.
\`\`\`

### 4. CREATE/MODIFY A SINGLE FOLDER
\`\`\`FOLDER
{
  "id": "folder_id",
  "label": "Folder Name",
  "icon": "emoji",
  "color": "#hexcolor",
  "phrases": ["phrase 1", "phrase 2"]
}
\`\`\`

## GUIDELINES
- Be concise in explanations
- Always provide actionable output with the structured blocks above
- For blueprints, include 6-10 folders with 5-10 diverse phrases each
- Use descriptive, evocative phrases that work well for image generation
- Match the user's style and intent
- For photography genres: include instruction, subject, pose, environment, camera, lighting, color, style, mood, and quality folders
- Use colors that feel appropriate to the genre (warm for portraits, cool for landscapes, etc.)

## FOLDER COLOR PALETTE
Use these hex colors: #74B9FF (blue), #FF6B6B (red), #4ECDC4 (teal), #45B7D1 (cyan), #BB8FCE (purple), #F7DC6F (yellow), #FFA94D (orange), #85C1E9 (light blue), #F1948A (pink), #82E0AA (green), #D7BDE2 (lavender)

Be helpful, creative, and make the user's prompt engineering experience magical!`;
    }
    
    function parseAssistantResponse(text) {
      let html = '';
      let lastIndex = 0;
      
      // Pattern to match action blocks
      const blockPattern = /```(BLUEPRINT|ADD_PHRASES|PROMPT|FOLDER)\n([\s\S]*?)```/g;
      let match;
      
      while ((match = blockPattern.exec(text)) !== null) {
        // Add text before this block
        const beforeText = text.slice(lastIndex, match.index);
        if (beforeText.trim()) {
          html += formatPlainText(beforeText);
        }
        
        const blockType = match[1];
        const blockContent = match[2].trim();
        
        try {
          const data = JSON.parse(blockContent);
          html += renderActionBlock(blockType, data);
        } catch (e) {
          html += `<div class="action-block"><div class="action-block-header">‚ö†Ô∏è Parse Error</div><div class="action-block-content">${escapeHtml(blockContent)}</div></div>`;
        }
        
        lastIndex = match.index + match[0].length;
      }
      
      // Add remaining text
      const afterText = text.slice(lastIndex);
      if (afterText.trim()) {
        html += formatPlainText(afterText);
      }
      
      return html || formatPlainText(text);
    }
    
    function formatPlainText(text) {
      return text
        .replace(/\n/g, '<br>')
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/`(.*?)`/g, '<code style="background:rgba(255,255,255,0.1);padding:2px 4px;border-radius:3px;">$1</code>');
    }
    
    function renderActionBlock(type, data) {
      const blockId = 'action_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      
      // Store data in a global map that persists
      if (!window.actionDataStore) window.actionDataStore = {};
      window.actionDataStore[blockId] = { type, data };
      
      console.log('Stored action:', blockId, type, data);
      
      switch (type) {
        case 'BLUEPRINT':
          return renderBlueprintBlock(blockId, data);
        case 'ADD_PHRASES':
          return renderAddPhrasesBlock(blockId, data);
        case 'PROMPT':
          return renderPromptBlock(blockId, data);
        case 'FOLDER':
          return renderFolderBlock(blockId, data);
        default:
          return `<div class="action-block"><pre>${JSON.stringify(data, null, 2)}</pre></div>`;
      }
    }
    
    // Helper to get stored action data
    function getActionData(blockId) {
      const stored = window.actionDataStore?.[blockId];
      if (!stored) {
        console.error('Action not found:', blockId);
        showToast('‚ö†Ô∏è Action expired. Please regenerate.');
        return null;
      }
      return stored;
    }
    
    function renderBlueprintBlock(blockId, data) {
      const folderPreviews = (data.folders || []).slice(0, 8).map(f => `
        <div class="blueprint-preview-folder">
          <div class="blueprint-preview-folder-icon">${f.icon || 'üìÅ'}</div>
          <div class="blueprint-preview-folder-name">${f.label}</div>
          <div class="blueprint-preview-folder-count">${f.phrases?.length || 0} phrases</div>
        </div>
      `).join('');
      
      return `
        <div class="action-block">
          <div class="action-block-header">üé® New Blueprint: ${data.name || 'Untitled'}</div>
          <div style="font-size:11px;color:#888;margin-bottom:10px;">${data.description || ''}</div>
          <div class="blueprint-preview">${folderPreviews}</div>
          <div class="action-block-buttons">
            <button class="action-btn-apply" onclick="applyBlueprintAction('${blockId}')">
              ‚ú® Load Blueprint
            </button>
            <button class="action-btn-secondary" onclick="previewBlueprintAction('${blockId}')">
              üëÅÔ∏è Preview
            </button>
          </div>
        </div>
      `;
    }
    
    function renderAddPhrasesBlock(blockId, data) {
      const phrasePreviews = (data.phrases || []).slice(0, 6).map(p => 
        `<span class="action-block-phrase">${escapeHtml(p.substring(0, 40))}${p.length > 40 ? '...' : ''}</span>`
      ).join('');
      
      // Build folder selector
      const folderOptions = categories.map(c => 
        `<option value="${c.id}" ${c.id === data.folderId ? 'selected' : ''}>${c.icon} ${c.label}</option>`
      ).join('');
      
      return `
        <div class="action-block">
          <div class="action-block-header">‚ûï Add ${data.phrases?.length || 0} Phrases</div>
          <select class="action-folder-select" id="folderSelect_${blockId}">
            ${folderOptions}
          </select>
          <div class="action-block-preview">
            <div class="action-block-preview-label">Phrases to add:</div>
            <div class="action-block-phrases">${phrasePreviews}</div>
          </div>
          <div class="action-block-buttons">
            <button class="action-btn-apply" onclick="applyAddPhrasesAction('${blockId}')">
              ‚ûï Add to Folder
            </button>
          </div>
        </div>
      `;
    }
    
    function renderPromptBlock(blockId, data) {
      // Check if we have a breakdown
      const hasBreakdown = data.breakdown && Object.keys(data.breakdown).length > 0;
      
      return `
        <div class="action-block">
          <div class="action-block-header">üìù Suggested Prompt</div>
          <div class="action-block-content">${escapeHtml(data.text || '')}</div>
          <div class="action-block-buttons">
            <button class="action-btn-apply" onclick="applyPromptAction('${blockId}')">
              üìã Copy Prompt
            </button>
            ${hasBreakdown ? `
            <button class="action-btn-secondary" onclick="loadPromptToSlotsAction('${blockId}')">
              üß± Fill Slots
            </button>
            ` : ''}
          </div>
        </div>
      `;
    }
    
    function renderFolderBlock(blockId, data) {
      const phrasePreviews = (data.phrases || []).slice(0, 4).map(p => 
        `<span class="action-block-phrase">${escapeHtml(p.substring(0, 30))}...</span>`
      ).join('');
      
      return `
        <div class="action-block">
          <div class="action-block-header">${data.icon || 'üìÅ'} Folder: ${data.label}</div>
          <div class="action-block-preview">
            <div class="action-block-preview-label">${data.phrases?.length || 0} phrases:</div>
            <div class="action-block-phrases">${phrasePreviews}</div>
          </div>
          <div class="action-block-buttons">
            <button class="action-btn-apply" onclick="applyFolderAction('${blockId}')">
              ‚ûï Add Folder
            </button>
            <button class="action-btn-secondary" onclick="replaceFolderAction('${blockId}')">
              üîÑ Replace Existing
            </button>
          </div>
        </div>
      `;
    }
    
    // ============ ACTION HANDLERS ============
    
    // Helper to strip leading emoji from label (AI sometimes includes emoji in both icon and label)
    function stripLeadingEmoji(text) {
      if (!text) return text;
      // Match leading emoji (including compound emojis) and whitespace
      return text.replace(/^[\p{Emoji}\p{Emoji_Modifier}\p{Emoji_Component}\p{Emoji_Modifier_Base}\p{Emoji_Presentation}\s]+/u, '').trim() || text;
    }
    
    // Helper to create clean folder ID from label
    function createFolderId(label) {
      if (!label) return 'folder_' + Date.now();
      return stripLeadingEmoji(label).toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_|_$/g, '') || 'folder_' + Date.now();
    }
    
    function applyBlueprintAction(blockId) {
      const stored = getActionData(blockId);
      if (!stored || stored.type !== 'BLUEPRINT') {
        console.error('No stored data for blockId:', blockId);
        return;
      }
      
      const data = stored.data;
      console.log('Applying blueprint:', data);
      
      try {
        // Create unique ID for this blueprint
        const blueprintId = 'assistant_' + Date.now();
        const blueprintName = stripLeadingEmoji(data.name) || data.name || 'Custom Blueprint';
        const blueprintIcon = data.icon || 'üé®';
        const blueprintDescription = stripLeadingEmoji(data.description) || data.description || 'Created by assistant';
        
        // Build categories from folders - strip emoji from label if icon is provided
        const newCategories = (data.folders || []).map(f => ({
          id: f.id || createFolderId(f.label),
          label: stripLeadingEmoji(f.label) || f.label,
          icon: f.icon || 'üìÅ',
          color: f.color || '#74B9FF'
        }));
        
        // Build library (phrases for each folder) - use same ID logic as categories
        const newLibrary = {};
        (data.folders || []).forEach(f => {
          const folderId = f.id || createFolderId(f.label);
          newLibrary[folderId] = f.phrases || [];
        });
        
        // Create the blueprint object (matching the structure used by saveCurrentAsBlueprint)
        const newBlueprint = {
          id: blueprintId,
          name: blueprintName,
          icon: blueprintIcon,
          description: blueprintDescription,
          categories: newCategories.map(cat => ({...cat}))
        };
        
        console.log('New blueprint object:', newBlueprint);
        
        // Add to custom blueprints array
        customBlueprints.push(newBlueprint);
        console.log('Custom blueprints count:', customBlueprints.length);
        
        // Apply the blueprint (same as loadBlueprint does)
        categories = newCategories.map(cat => ({...cat}));
        currentBlueprintId = blueprintId;
        
        // Set library for all categories
        newCategories.forEach(cat => {
          library[cat.id] = newLibrary[cat.id] || [];
        });
        
        // Clear slots
        slots = {};
        categories.forEach(cat => {
          slots[cat.id] = [];
        });
        
        // Clear expanded state
        expandedCategory = null;
        
        // Save first so everything persists
        saveToStorage();
        console.log('Saved to storage');
        
        // Force complete UI refresh
        setTimeout(() => {
          renderLibrary();
          renderSlots();
          renderPreview();
          updateBlueprintButton();
          console.log('UI refreshed');
        }, 50);
        
        // Close assistant to show the result
        if (assistantActive) {
          toggleAssistant();
        }
        
        showToast(`‚ú® Saved & loaded: ${blueprintName}`);
        console.log('Blueprint applied successfully');
        
      } catch (e) {
        console.error('Blueprint apply error:', e);
        console.error('Error stack:', e.stack);
        // Still try to show what we have
        showToast(`‚ö†Ô∏è Partial load - check console`);
      }
    }
    
    function previewBlueprintAction(blockId) {
      const stored = getActionData(blockId);
      if (!stored) return;
      
      const data = stored.data;
      let preview = `Blueprint: ${data.name}\n${data.description || ''}\n\nFolders:\n`;
      (data.folders || []).forEach(f => {
        preview += `\n${f.icon} ${f.label} (${f.phrases?.length || 0} phrases)\n`;
        (f.phrases || []).forEach(p => {
          preview += `  ‚Ä¢ ${p}\n`;
        });
      });
      
      alert(preview);
    }
    
    function applyAddPhrasesAction(blockId) {
      const stored = getActionData(blockId);
      if (!stored || stored.type !== 'ADD_PHRASES') return;
      
      // Get selected folder from dropdown
      const select = document.getElementById(`folderSelect_${blockId}`);
      const folderId = select ? select.value : stored.data.folderId;
      
      if (!folderId || !library[folderId]) {
        showToast('‚ö†Ô∏è Folder not found');
        return;
      }
      
      const newPhrases = stored.data.phrases || [];
      const existingPhrases = new Set(library[folderId]);
      let addedCount = 0;
      
      newPhrases.forEach(p => {
        if (!existingPhrases.has(p)) {
          library[folderId].push(p);
          addedCount++;
        }
      });
      
      renderLibrary();
      saveToStorage();
      showToast(`‚ûï Added ${addedCount} phrases to folder`);
    }
    
    function applyPromptAction(blockId) {
      const stored = getActionData(blockId);
      if (!stored || stored.type !== 'PROMPT') return;
      
      const text = stored.data.text || '';
      navigator.clipboard.writeText(text).then(() => {
        showToast('üìã Prompt copied!');
      }).catch(() => {
        showToast('‚ö†Ô∏è Could not copy');
      });
    }
    
    function loadPromptToSlotsAction(blockId) {
      const stored = getActionData(blockId);
      if (!stored || stored.type !== 'PROMPT') return;
      
      const data = stored.data;
      
      // If there's a breakdown, try to fill matching slots
      if (data.breakdown && Object.keys(data.breakdown).length > 0) {
        let filledCount = 0;
        Object.entries(data.breakdown).forEach(([key, value]) => {
          // Check if this category exists
          const category = categories.find(c => c.id === key);
          if (category && value) {
            // Add to slots array
            if (!slots[key]) slots[key] = [];
            slots[key] = [value]; // Replace with single value
            filledCount++;
          }
        });
        
        if (filledCount > 0) {
          renderSlots();
          renderPreview();
          saveToStorage();
          showToast(`üß± Loaded ${filledCount} slots`);
          return;
        }
      }
      
      // Fallback: If no breakdown or no slots matched, copy the text
      if (data.text) {
        navigator.clipboard.writeText(data.text).then(() => {
          showToast('üìã Copied prompt (no matching slots)');
        });
      } else {
        showToast('‚ö†Ô∏è No content to load');
      }
    }
    
    function applyFolderAction(blockId) {
      const stored = getActionData(blockId);
      if (!stored || stored.type !== 'FOLDER') return;
      
      const data = stored.data;
      const folderId = data.id || createFolderId(data.label);
      const cleanLabel = stripLeadingEmoji(data.label) || data.label;
      
      // Check if folder exists
      if (categories.find(c => c.id === folderId)) {
        // Add phrases to existing folder
        const newPhrases = data.phrases || [];
        const existingPhrases = new Set(library[folderId] || []);
        let addedCount = 0;
        
        newPhrases.forEach(p => {
          if (!existingPhrases.has(p)) {
            library[folderId] = library[folderId] || [];
            library[folderId].push(p);
            addedCount++;
          }
        });
        
        showToast(`‚ûï Added ${addedCount} phrases`);
      } else {
        // Create new folder
        categories.push({
          id: folderId,
          label: cleanLabel,
          icon: data.icon || 'üìÅ',
          color: data.color || '#74B9FF'
        });
        library[folderId] = data.phrases || [];
        slots[folderId] = [];
        
        showToast(`üìÅ Created: ${data.label}`);
      }
      
      renderLibrary();
      renderSlots();
      saveToStorage();
    }
    
    function replaceFolderAction(blockId) {
      const stored = getActionData(blockId);
      if (!stored || stored.type !== 'FOLDER') return;
      
      const data = stored.data;
      const folderId = data.id || createFolderId(data.label);
      const cleanLabel = stripLeadingEmoji(data.label) || data.label;
      
      // Find or create folder
      let folder = categories.find(c => c.id === folderId);
      if (!folder) {
        folder = {
          id: folderId,
          label: cleanLabel,
          icon: data.icon || 'üìÅ',
          color: data.color || '#74B9FF'
        };
        categories.push(folder);
        slots[folderId] = [];
      } else {
        folder.label = cleanLabel || folder.label;
        folder.icon = data.icon || folder.icon;
        folder.color = data.color || folder.color;
      }
      
      // Replace phrases in library
      library[folderId] = data.phrases || [];
      
      renderLibrary();
      renderSlots();
      saveToStorage();
      showToast(`üîÑ Replaced: ${cleanLabel}`);
    }
    
    // ============ VISION CHAT ============
    let visionChatImageId = null;
    let visionChatHistory = [];
    let visionChatWaiting = false;
    
    function openVisionChat(imageId) {
      const img = generatedImages.find(i => i.id === imageId);
      if (!img) return;
      
      visionChatImageId = imageId;
      visionChatHistory = [];
      
      document.getElementById('visionChatImage').src = 'data:image/png;base64,' + img.data;
      document.getElementById('visionChatPrompt').textContent = img.prompt || 'No prompt';
      document.getElementById('visionChatMessages').innerHTML = `
        <div class="vision-chat-welcome">
          <div class="vision-chat-welcome-icon">üîç</div>
          <div class="vision-chat-welcome-text">Ask me about this image!</div>
          <div class="vision-chat-welcome-suggestions">
            <button onclick="sendVisionSuggestion('Describe this image')">Describe</button>
            <button onclick="sendVisionSuggestion('What could be improved?')">Improve</button>
            <button onclick="sendVisionSuggestion('Write a better prompt')">Better prompt</button>
          </div>
        </div>`;
      document.getElementById('visionChatInput').value = '';
      
      document.getElementById('visionChatOverlay').classList.add('active');
      document.getElementById('visionChatModal').classList.add('active');
    }
    
    function closeVisionChat() {
      document.getElementById('visionChatOverlay').classList.remove('active');
      document.getElementById('visionChatModal').classList.remove('active');
      visionChatImageId = null;
      visionChatHistory = [];
    }
    
    function sendVisionSuggestion(text) {
      document.getElementById('visionChatInput').value = text;
      sendVisionMessage();
    }
    
    async function sendVisionMessage() {
      if (visionChatWaiting) return;
      
      const input = document.getElementById('visionChatInput');
      const message = input.value.trim();
      if (!message) return;
      
      const apiKey = getGoogleApiKey();
      if (!apiKey) { showToast('Add Google API key first'); return; }
      
      const img = generatedImages.find(i => i.id === visionChatImageId);
      if (!img) return;
      
      input.value = '';
      visionChatWaiting = true;
      
      const container = document.getElementById('visionChatMessages');
      if (visionChatHistory.length === 0) container.innerHTML = '';
      
      container.innerHTML += `<div class="vision-chat-message user">${message}</div>`;
      container.innerHTML += '<div class="vision-chat-typing"><span></span><span></span><span></span></div>';
      container.scrollTop = container.scrollHeight;
      
      visionChatHistory.push({ role: 'user', content: message });
      
      try {
        const contents = [];
        for (let i = 0; i < visionChatHistory.length; i++) {
          const msg = visionChatHistory[i];
          if (i === 0 && msg.role === 'user') {
            contents.push({
              role: 'user',
              parts: [
                { inlineData: { mimeType: 'image/png', data: img.data } },
                { text: `Original prompt: "${img.prompt}"\n\nQuestion: ${msg.content}` }
              ]
            });
          } else {
            contents.push({
              role: msg.role === 'user' ? 'user' : 'model',
              parts: [{ text: msg.content }]
            });
          }
        }
        
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ contents })
        });
        
        const data = await response.json();
        container.querySelector('.vision-chat-typing')?.remove();
        
        if (data.candidates?.[0]?.content?.parts?.[0]?.text) {
          const reply = data.candidates[0].content.parts[0].text;
          visionChatHistory.push({ role: 'assistant', content: reply });
          container.innerHTML += `<div class="vision-chat-message assistant">${reply.replace(/\n/g, '<br>')}</div>`;
        } else {
          container.innerHTML += '<div class="vision-chat-message assistant">Could not get response</div>';
        }
      } catch (e) {
        container.querySelector('.vision-chat-typing')?.remove();
        container.innerHTML += `<div class="vision-chat-message assistant">Error: ${e.message}</div>`;
      }
      
      visionChatWaiting = false;
      container.scrollTop = container.scrollHeight;
    }
    
    // Update preview to enable/disable generate button
    const originalRenderPreview = renderPreview;
    renderPreview = function() {
      originalRenderPreview();
      const preview = document.getElementById('previewContent');
      const generateBtn = document.getElementById('generateBtn');
      if (generateBtn) {
        generateBtn.disabled = preview.classList.contains('empty');
      }
      updateImageGeneratorUI();
    };
    
    initializeData();
    initDragSystem();
    loadGalleryFromStorage();
    renderLibrary();
    renderSlots();
    renderReferences();
    renderPreview();
    renderTemplateSelect();
    updateBlueprintButton();
  </script>
</body>
</html>
